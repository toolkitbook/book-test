---
layout: default
title: C++ Toolkit test
nav: pages/ch_ser
---

<span class="label">13</span>Data Serialization (ASN.1, XML)
============================================================

Last Update: April 7, 2015.

The SERIAL API [Library <span class="nctnt ncbi-path">xserial</span>:[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/serial)]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The overview for this chapter consists of the following topics:

-   Introduction

-   Chapter Outline

### Introduction

The Serial library provides a means for loading, accessing, manipulating, and serialization of data in a formatted way. It supports serialization in [ASN.1](http://www.itu.int/ITU-T/studygroups/com17/languages/) (text or BER encoding), [XML](http://www.w3.org/XML), and [JSON](http://json.org) formats. See also the [DATATOOL documentation](ch_app.html#ch_app.datatool) discussion of generating C++ code for serializable objects from the corresponding ASN.1 definition.

The structure of data is described by some sort of formal language. In our case it can be ASN.1, DTD or XML Schema. Based on such specification, [DATATOOL](ch_app.html#ch_app.datatool) application, which is part of NCBI C++ toolkit, generates a collection of data storage classes that can be used to store and serialize data. The design purpose was to make these classes as lightweight as possible, moving all details of serialization into specialized classes - [“object streams”](#“object-streams”). Structure of the data is described with the help of [“type information”](#“type-information”). Data objects contain data and type information only. Any such data storage object can be viewed as a node tree that provides random access to its data. The Serial library provides a means of[traversing](#-traversing) this data tree without knowing its structure in advance – using only type information; C++ code generated by DATATOOL makes it possible to access any child node directly.

[“Object streams”](#“object-streams”) are intermediaries between data storage objects and input or output stream. They perform encoding or decoding of data according to format specifications. Guided by the type information embedded into data object, on reading they allocate memory when needed, fill in data, and validate that all mandatory data is present; on writing they guarantee that all relevant data is written and that the resulting document is well-formed. All it takes to read or write a top-level data object is one function call – all the details are handled by an object stream.

Closely related to serialization is the task of converting data from one format into another. One approach could be reading data object completely into memory and then writing it in another format. The only problem is that the size of data can be huge. To simplify this task and to avoid storing data in memory, the serial library provides the [“object stream copier”](#“object-stream-copier”) class. It reads data by small chunks and writes it immediately after reading. In addition to small memory footprint, it also works much faster.

Input data can be very large in size; also, reading it completely into memory could not be the goal of processing. Having a large file of data, one might want to investigate information containers only of a particular type. Serial library provides a variety of means for doing this. The list includes [read](#read) and [write](#write) hooks, several types of [stream iterators](#stream-iterators), and [filter templates](#filter-templates). It is worth to note that, when using read hooks to read child nodes, one might end up with an invalid top-level data object; or, when using write hooks, one might begin with an invalid object and fill in missing data on the fly – in hooks.

In essence, “hook” is a callback function that client application provides to serial library. Client application installs the hook, then reads (or writes) data object, and somewhere from the depths of serialization processing, the library calls this hook function at appropriate times, for example, when a data chunk of specified type is about to be read. It is also possible to install [context-specific hooks](#context-specific-hooks). Such hooks are triggered when serializing a particular object type in a particular structural context; for example, for all objects of class A which are contained in object B.

### Chapter Outline

The following is an outline of the topics presented in this chapter:

-   [CObject[IO]Streams](#cobjectiostreams)

    -   [Format Specific Streams: The CObject[IO]Stream classes](#format-specific-streams-the-cobjectiostream-classes)

    -   [The CObjectIStream (\*) classes](#the-cobjectistream-*-classes)

    -   [The CObjectOStream (\*) classes](#the-cobjectostream-*-classes)

    -   [The CObjectStreamCopier (\*) classes](#the-cobjectstreamcopier-*-classes)

    -   [Type-specific I/O routines – the hook classes](#type-specific-io-routines-–-the-hook-classes)

        -   [Hook Sample](#hook-sample)

        -   [Read mode hooks](#read-mode-hooks)

        -   [Write mode hooks](#write-mode-hooks)

        -   [Copy mode hooks](#copy-mode-hooks)

        -   [Skip mode hooks](#skip-mode-hooks)

        -   [The CObjectHookGuard class](#the-cobjecthookguard-class)

        -   [Stack Path Hooks](#stack-path-hooks)

        -   [Hooking anonymous objects](#hooking-anonymous-objects)

    -   [Stream Iterators](#stream-iterators)

    -   [The ByteBlock and CharBlock classes](#the-byteblock-and-charblock-classes)

    -   [NCBI C++ Toolkit Network Service (RPC) Clients](#ncbi-c++-toolkit-network-service-rpc-clients)

        -   [Introduction and Use](#introduction-and-use)

        -   [Implementation Details](#implementation-details)

    -   [Verification of Class Member Initialization](#verification-of-class-member-initialization)

        -   [Initialization Verification in CSerialObject Classes](#initialization-verification-in-cserialobject-classes)

        -   [Initialization Verification in Object Streams](#initialization-verification-in-object-streams)

    -   [Simplified serialization interface](#simplified-serialization-interface)

    -   [Finding in input stream objects of a specific type](#finding-in-input-stream-objects-of-a-specific-type)

-   [The NCBI C++ Toolkit Iterators](#the-ncbi-c++-toolkit-iterators)

    -   [STL generic iterators](#stl-generic-iterators)

    -   [CTypeIterator (\*) and CTypeConstIterator (\*)](#ctypeiterator-*-and-ctypeconstiterator-*)

    -   [Class hierarchies, embedded objects, and the NCBI C++ type iterators](#class-hierarchies-embedded-objects-and-the-ncbi-c++-type-iterators)

    -   [CObjectIterator (\*) and CObjectConstIterator (\*)](#cobjectiterator-*-and-cobjectconstiterator-*)

    -   [CStdTypeIterator (\*) and CStdTypeConstIterator (\*)](#cstdtypeiterator-*-and-cstdtypeconstiterator-*)

    -   [CTypesIterator (\*)](#ctypesiterator-*)

    -   [Context Filtering in Type Iterators](#context-filtering-in-type-iterators)

    -   [Additional Information](#additional-information)

-   [Processing Serial Data](#processing-serial-data)

    -   [Accessing the object header files and serialization libraries](#accessing-the-object-header-files-and-serialization-libraries)

    -   [Reading and writing serial data](#reading-and-writing-serial-data)

    -   [Reading and writing binary JSON data](#reading-and-writing-binary-json-data)

    -   [Determining Which Header Files to Include](#determining-which-header-files-to-include)

    -   [Determining Which Libraries to Link To](#determining-which-libraries-to-link-to)

-   [User-defined type information](#user-defined-type-information)

    -   [Introduction](#introduction)

    -   [Installing a GetTypeInfo() function: the BEGIN\_/END\_ macros](#installing-a-gettypeinfo-function-the-beginend-macros)

        -   [List of the BEGIN\_/END\_ macros](#list-of-the-beginend-macros)

    -   [Specifying internal structure and class inheritance: the ADD\_ macros](#specifying-internal-structure-and-class-inheritance-the-add-macros)

-   [Runtime Object Type Information](#runtime-object-type-information)

    -   [Introduction](#introduction)

        -   [Type and Object specific info](#type-and-object-specific-info)

    -   [Motivation](#motivation)

    -   [Object Information Classes](#object-information-classes)

    -   [CObjectTypeInfo (\*)](#cobjecttypeinfo-*)

    -   [CConstObjectInfo (\*)](#cconstobjectinfo-*)

    -   [CObjectInfo (\*)](#cobjectinfo-*)

    -   [Usage of object type information](#usage-of-object-type-information)

-   [Choice objects in the NCBI C++ Toolkit](#choice-objects-in-the-ncbi-c++-toolkit)

    -   [Introduction](#introduction)

    -   [C++ choice objects](#c++-choice-objects)

-   [Traversing a Data Structure](#traversing-a-data-structure)

    -   [Locating the Class Definitions](#locating-the-class-definitions)

    -   [Accessing and Referencing Data Members](#accessing-and-referencing-data-members)

    -   [Traversing a Biostruc](#traversing-a-biostruc)

    -   [Iterating Over Containers](#iterating-over-containers)

-   [Managing ASN.1 Specification Versions](#managing-asn1-specification-versions)

-   [SOAP support](#soap-support)

    -   [SOAP message](#soap-message)

    -   [SOAP client - CSoapHttpClient](#soap-client---csoaphttpclient)

    -   [SOAP server - CSoapServerApplication](#soap-server---csoapserverapplication)

    -   [Generating a SOAP client using DATATOOL](#generating-a-soap-client-using-datatool)

    -   [Sample SOAP server and client](#sample-soap-server-and-client)

        -   [Sample server](#sample-server)

        -   [Sample client](#sample-client)

-   [Test Cases [src/serial/test]](#test-cases-srcserialtest)

<span class="nctnt ncbi-class">CObject[IO]Streams</span>
--------------------------------------------------------

The following topics are discussed in this section:

-   [Format Specific Streams: The CObject[IO]Stream classes](#format-specific-streams-the-cobjectiostream-classes)

-   [The CObjectIStream (\*) classes](#the-cobjectistream-*-classes)

-   [The CObjectOStream (\*) classes](#the-cobjectostream-*-classes)

-   [The CObjectStreamCopier (\*) classes](#the-cobjectstreamcopier-*-classes)

-   [Type-specific I/O routines – the hook classes](#type-specific-io-routines-–-the-hook-classes)

    -   [Hook Sample](#hook-sample)

    -   [Read mode hooks](#read-mode-hooks)

    -   [Write mode hooks](#write-mode-hooks)

    -   [Copy mode hooks](#copy-mode-hooks)

    -   [Skip mode hooks](#skip-mode-hooks)

    -   [The CObjectHookGuard class](#the-cobjecthookguard-class)

    -   [Stack Path Hooks](#stack-path-hooks)

    -   [Hooking anonymous objects](#hooking-anonymous-objects)

-   [Stream Iterators](#stream-iterators)

-   [The ByteBlock and CharBlock classes](#the-byteblock-and-charblock-classes)

-   [NCBI C++ Toolkit Network Service Clients](#ncbi-c++-toolkit-network-service-clients)

-   [Verification of Class Member Initialization](#verification-of-class-member-initialization)

-   [Simplified serialization interface](#simplified-serialization-interface)

-   [Finding in input stream objects of a specific type](#finding-in-input-stream-objects-of-a-specific-type)

### Format Specific Streams: The <span class="nctnt ncbi-class">CObject[IO]Stream</span> classes

The reading and writing of serialized data objects entails satisfying two independent sets of constraints and specifications: (1) <span class="nctnt ncbi-monospace">format-specific</span> parsing and encoding schemes, and (2) <span class="nctnt ncbi-monospace">object-specific</span> internal structures and rules of composition. The NCBI C++ Toolkit implements serial IO processes by combining a set of <span class="nctnt ncbi-monospace">object stream</span> classes with an independently defined set of <span class="nctnt ncbi-monospace">data object</span> classes. These classes are implemented in the <span class="nctnt ncbi-path">serial</span> and <span class="nctnt ncbi-path">objects</span> directories respectively.

The base classes for the object stream classes are [CObjectIStream](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStream.html) and [CObjectOStream](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStream.html). Each of these base classes has derived subclasses which specialize in different formats, including XML, binary ASN.1, and text ASN.1. A simple example program, <span class="nctnt ncbi-path">xml2asn.cpp</span> (see [Code Sample 1](#code-sample-1)), described in [Processing serial data](#processing-serial-data), uses these object stream classes in conjunction with a <span class="nctnt ncbi-class">CBiostruct</span> object to translate a file from XML encoding to ASN.1 formats. In this chapter, we consider in more detail the class definitions for object streams, and how the [type information](#type-information) associated with the data is used to implement serial input and output.

#### Code Sample 1. xml2asn.cpp

    // File name: xml2asn.cpp
    // Description: Reads an XML Biostruc file into memory
    //      and saves it in ASN.1 text and binary formats.

    #include <corelib/ncbistd.hpp>
    #include <corelib/ncbiapp.hpp>
    #include <serial/serial.hpp>
    #include <serial/objistr.hpp>
    #include <serial/objostr.hpp>
    #include <objects/mmdb1/Biostruc.hpp>

    USING_NCBI_SCOPE;

    class CTestAsn : public CNcbiApplication {
    public:
        virtual int Run ();
    };

    using namespace objects;

    int CTestAsn::Run() {
        auto_ptr<CObjectIStream>
            xml_in(CObjectIStream::Open("1001.xml", eSerial_Xml));
        auto_ptr<CObjectOStream>
            txt_out(CObjectOStream::Open("1001.asntxt", eSerial_AsnText));
        auto_ptr<CObjectOStream>
            bin_out(CObjectOStream::Open("1001.asnbin", eSerial_AsnBinary));
        CBiostruc bs;
        *xml_in >> bs;
        *txt_out << bs;
        *bin_out << bs;
        return 0;
    }

    int main(int argc, const char* argv[])
    {
        CNcbiOfstream diag("asntrans.log");
        SetDiagStream(&diag);
        CTestAsn theTestApp;
        return theTestApp.AppMain(argc, argv);
    }

Each object stream specializes in a serial data format and a direction (in/out). It is not until the input and output operators are applied to these streams, in conjunction with a specified serializable object, that the object-specific type information comes into play. For example, if <span class="nctnt ncbi-var">instr</span> is a <span class="nctnt ncbi-class">CObjectIStream</span>, the statement: <span class="nctnt ncbi-code">instr \>\> myObject</span> invokes a <span class="nctnt ncbi-func">Read()</span> method associated with the input stream, whose sole argument is a [CObjectInfo](#cobjectinfo) for <span class="nctnt ncbi-var">myObject</span>.

Similarly, the output operators, when applied to a <span class="nctnt ncbi-class">CObjectOstream</span> in conjunction with a serializable object, will invoke a <span class="nctnt ncbi-func">Write()</span> method on the output stream which accesses the object's type information. The object's type information defines what tag names and value types should be encountered on the stream, while the <span class="nctnt ncbi-class">CObject[IO]Stream</span> subclasses specialize the data serialization format.

The input and output operators (<span class="nctnt ncbi-code">\<\<</span> and <span class="nctnt ncbi-code">\>\></span>) are declared in [serial/serial.hpp](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial/serial.hpp) header.

### The <span class="nctnt ncbi-class">CObjectIStream</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStream.html)) classes

<span class="nctnt ncbi-class">CObjectIStream</span> is a virtual base class for the [CObjectIStreamXml](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStreamXml.html), [CObjectIStreamAsn](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStreamAsn.html), and [CObjectIStreamAsnBinary](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStreamAsnBinary.html) classes. As such, it has no public constructors, and its user interface includes the following methods:

-   <span class="nctnt ncbi-func">Open()</span>

-   <span class="nctnt ncbi-func">Close()</span>

-   <span class="nctnt ncbi-func">GetDataFormat()</span>

-   <span class="nctnt ncbi-func">ReadFileHeader()</span>

-   <span class="nctnt ncbi-func">Read()</span>

-   <span class="nctnt ncbi-func">ReadObject()</span>

-   <span class="nctnt ncbi-func">ReadSeparateObject()</span>

-   <span class="nctnt ncbi-func">Skip()</span>

-   <span class="nctnt ncbi-func">SkipObject()</span>

There are several <span class="nctnt ncbi-func">Open()</span> methods; most of these are static class methods that return a pointer to a newly created <span class="nctnt ncbi-class">CObjectIStream</span>. Typically, these methods are used with an <span class="nctnt ncbi-class">auto\_ptr</span>, as in:

    auto_ptr<CObjectIStream> xml_in(CObjectIStream::Open(filename, eSerial_Xml));

Here, an XML format is specified by the enumerated value <span class="nctnt ncbi-var">eSerial\_Xml</span>, defined in [ESerialDataFormat](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ESerialDataFormat). Because these methods are static, they can be used to create a new instance of a <span class="nctnt ncbi-class">CObjectIStream</span> subclass, and open it with one statement. In this example, a [CObjectIStreamXml](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStreamXml.html) is created and opened on the file <span class="nctnt ncbi-var">filename</span>.

An additional non-static <span class="nctnt ncbi-func">Open()</span> method is provided, which can only be invoked as a member function of a previously instantiated object stream (whose format type is of course, implicit to its class). This method takes a <span class="nctnt ncbi-class">CNcbiIstream</span> and a flag indicating whether or not ownership of the <span class="nctnt ncbi-class">CNcbiIstream</span> should be transferred (so that it can be deleted automatically when the object stream is closed):

    void Open(CNcbiIstream& inStream, EOwnership deleteInStream = eNoOwnership);

The next three methods have the following definitions. <span class="nctnt ncbi-func">Close()</span> closes the stream. <span class="nctnt ncbi-func">GetDataFormat()</span> returns the enumerated <span class="nctnt ncbi-type">ESerialDataFormat</span> for the stream. <span class="nctnt ncbi-func">ReadFileHeader()</span> reads the first line from the file, and returns it in a string. This might be used for example, in the following context:

    auto_ptr<CObjectIStream> in(CObjectIStream::Open(fname, eSerial_AsnText));
    string type = in.ReadFileHeader();
    if (type.compare("Seq-entry") == 0) {
        CSeq_entry seqent;
        in->Read(ObjectInfo(seqent), eNoFileHeader);
        // ...
    }
    else if (type.compare("Bioseq-set") == 0) {
        CBioseq_set seqset;
        in->Read(ObjectInfo(seqset), eNoFileHeader);
        // ...
    }

> The <span class="nctnt ncbi-func">ReadFileHeader()</span> method for the base <span class="nctnt ncbi-class">CObjectIStream</span> class returns an empty string. Only those stream classes which specialize in ASN.1 text or XML formats have actual implementations for this method.

Several <span class="nctnt ncbi-func">Read\*()</span> methods are provided for usage in different contexts. <span class="nctnt ncbi-func">CObjectIStream::Read()</span> should be used for reading a top-level "root" object from a data file. For convenience, the input operator <span class="nctnt ncbi-code">\>\></span>, as described above, indirectly invokes this method on the input stream, using a [CObjectTypeInfo](#cobjecttypeinfo) object derived from <span class="nctnt ncbi-var">myObject</span>. By default, the <span class="nctnt ncbi-func">Read()</span> method first calls <span class="nctnt ncbi-func">ReadFileHeader()</span>, and then calls <span class="nctnt ncbi-func">ReadObject()</span>. Accordingly, calls to <span class="nctnt ncbi-func">Read()</span> which follow the usage of <span class="nctnt ncbi-func">ReadFileHeader()</span>**must** include the optional <span class="nctnt ncbi-var">eNoFileHeader</span> argument.

Most data objects also contain embedded objects, and the default behavior of <span class="nctnt ncbi-func">Read()</span> is to load the top-level object, along with all of its contained subobjects into memory. In some cases this may require significant memory allocation, and it may be only the top-level object which is needed by the application. The next two methods, [ReadObject()](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ReadObject) and [ReadSeparateObject()](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ReadSeparateObject), can be used to load subobjects as either persistent data members of the root object or as temporary local objects. In contrast to <span class="nctnt ncbi-func">Read()</span>, these methods assume that there is no file header on the stream.

As a result of executing <span class="nctnt ncbi-code">ReadObject(member)</span>, the newly created subobject will be instantiated as a member of its parent object. In contrast, <span class="nctnt ncbi-code">ReadSeparateObject(local)</span>, instantiates the subobject in the local temporary variable only, and the corresponding data member in the parent object is set to an appropriate <span class="nctnt ncbi-monospace">null</span> representation for that data type. In this case, an attempt to reference that subobject after exiting the scope where it was created generates an error.

The <span class="nctnt ncbi-func">Skip()</span> and <span class="nctnt ncbi-func">SkipObject()</span> methods allow entire top-level objects and subobjects to be "skipped". In this case the input is still read from the stream and validated, but no object representation for that data is generated. Instead, the data is stored in a delay buffer associated with the object input stream, where it can be accessed as needed. <span class="nctnt ncbi-func">Skip()</span> should only be applied to top-level objects. As with the <span class="nctnt ncbi-func">Read()</span> method, the optional <span class="nctnt ncbi-type">ENoFileHeader</span> argument can be included if the file header has already been extracted from the data stream. <span class="nctnt ncbi-code">SkipObject(member)</span> may be applied to subobjects of the root object.

All of the <span class="nctnt ncbi-func">Read</span> and <span class="nctnt ncbi-func">Skip</span> methods are like wrapper functions, which define what activities take place immediately before and after the data is actually read. How and when the data is then loaded into memory is determined by the object itself. Each of the above methods ultimately calls <span class="nctnt ncbi-code">objTypeInfo-\>ReadData()</span> or <span class="nctnt ncbi-code">objTypeInfo-\>SkipData()</span>, where <span class="nctnt ncbi-var">objTypeInfo</span> is the static type information object associated with the data object. This scheme allows the user to install type-specific read, write, and copy hooks, which are described below. For example, the default behavior of loading all subobjects of the top-level object can be modified by installing appropriate read hooks which use the <span class="nctnt ncbi-func">ReadSeparateObject()</span> and <span class="nctnt ncbi-func">SkipObject()</span> methods where needed.

### The <span class="nctnt ncbi-class">CObjectOStream</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStream.html)) classes

The output object stream classes mirror the <span class="nctnt ncbi-class">CObjectIStream</span> classes. The <span class="nctnt ncbi-class">CObjectOStream</span> base class is used to derive the [CObjectOStreamXml](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStreamXml.html), [CObjectOStreamAsn](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStreamAsn.html), and [CObjectOStreamAsnBinary](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStreamAsnBinary.html) classes. There are no public constructors, and the user interface includes the following methods:

-   <span class="nctnt ncbi-func">Open()</span>

-   <span class="nctnt ncbi-func">Close()</span>

-   <span class="nctnt ncbi-func">GetDataFormat()</span>

-   <span class="nctnt ncbi-func">WriteFileHeader()</span>

-   <span class="nctnt ncbi-func">Write()</span>

-   <span class="nctnt ncbi-func">WriteObject()</span>

-   <span class="nctnt ncbi-func">WriteSeparateObject()</span>

-   <span class="nctnt ncbi-func">Flush()</span>

-   <span class="nctnt ncbi-func">FlushBuffer()</span>

Again, there are several <span class="nctnt ncbi-func">Open()</span> methods, which are static class methods that return a pointer to a newly created <span class="nctnt ncbi-class">CObjectOstream</span>:

    static CObjectOStream* Open(ESerialDataFormat format,
                                CNcbiOstream &outStream,
                                EOwnership deleteOutStream=eNoOwnership,
                                TSerial_Format_Flags formatFlags=0)

    static CObjectOStream* Open(ESerialDataFormat format,
                                const string &fileName,
                                TSerialOpenFlags openFlags=0,
                                TSerial_Format_Flags formatFlags=0)

    static CObjectOStream* Open(const string &fileName,
                                ESerialDataFormat format,
                                TSerial_Format_Flags formatFlags=0)

The <span class="nctnt ncbi-func">Write\*()</span> methods correspond to the <span class="nctnt ncbi-func">Read\*()</span> methods defined for the input streams. <span class="nctnt ncbi-func">Write()</span> first calls <span class="nctnt ncbi-func">WriteFileHeader()</span>, and then calls <span class="nctnt ncbi-func">WriteObject()</span>. <span class="nctnt ncbi-func">WriteSeparateObject()</span> can be used to write a temporary object (and all of its children) to the output stream. It is also possible to install type-specific <span class="nctnt ncbi-monospace">write</span> hooks. Like the <span class="nctnt ncbi-func">Read()</span> methods, these <span class="nctnt ncbi-func">Write()</span> methods serve as wrapper functions that define what occurs immediately before and after the data is actually written.

### The <span class="nctnt ncbi-class">CObjectStreamCopier</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectStreamCopier.html)) classes

The <span class="nctnt ncbi-class">CObjectStreamCopier</span> class is neither an input nor an output stream class, but a helper class, which allows one to "pass data through" without storing the intermediate objects in memory. Its sole constructor is:

    CObjectStreamCopier(CObjectIStream& in, CObjectOStream& out);

and its most important method is the <span class="nctnt ncbi-func">Copy(CObjectTypeInfo&)</span> method, which, given an object's description, reads that object from the input stream and writes it to the output stream. The serial formats of both the input and output object streams are implicit, and thus the translation between two different formats is performed automatically.

In keeping with the <span class="nctnt ncbi-func">Read</span> and <span class="nctnt ncbi-func">Write</span> methods of the <span class="nctnt ncbi-class">CObjectIStream</span> and <span class="nctnt ncbi-class">CObjectOStream</span> classes, the <span class="nctnt ncbi-func">Copy</span> method takes an optional <span class="nctnt ncbi-type">ENoFileHeader</span> argument, to indicate that the file header is not present in the input and should not be generated on the output. The <span class="nctnt ncbi-func">CopyObject()</span> method corresponds to the <span class="nctnt ncbi-func">ReadObject()</span> and <span class="nctnt ncbi-func">WriteObject()</span> methods.

As an example, consider how the <span class="nctnt ncbi-func">Run()</span> method in [xml2asn.cpp](#xml2asncpp) might be implemented differently using the <span class="nctnt ncbi-class">CObjectStreamCopier </span>class:

    int CTestAsn::Run() {
    auto_ptr<CObjectIStream>
    xml_in(CObjectIStream::Open("1001.xml", eSerial_Xml));
    auto_ptr<CObjectOStream>
    txt_out(CObjectOStream::Open("1001.asntxt", eSerial_AsnText));
    CObjectStreamCopier txt_copier(*xml_in, *txt_out);
    txt_copier.Copy(CBiostruc::GetTypeInfo());
    auto_ptr<CObjectOStream>
        bin_out(CObjectOStream::Open("1001.asnbin", eSerial_AsnBinary));
    CObjectStreamCopier bin_copier(*xml_in, *bin_out);
    bin_copier.Copy(CBiostruc::GetTypeInfo());
    return 0;
    }

It is also possible to install type-specific <span class="nctnt ncbi-func">Copy</span> hooks. Like the <span class="nctnt ncbi-func">Read</span> and <span class="nctnt ncbi-func">Write</span> methods, the <span class="nctnt ncbi-func">Copy</span> methods serve as wrapper functions that define what occurs immediately before and after the data is actually copied.

### Type-specific I/O routines – the hook classes

Much of the functionality needed to read and write serializable objects may be type-specific yet application-driven. Because the specializations may vary with the application, it does not make sense to implement fixed methods, yet we would like to achieve a similar kind of object-specific behavior.

To address these needs, the C++ Toolkit provides hook mechanisms, whereby the needed functionality can be installed with the object's static class [type information](#type-information) object. Local hooks apply to a selected stream whereas global hooks apply to all streams. <span class="nctnt highlight">Note:</span> global skip hooks are not supported.

For any given object type, stream, and processing mode (e.g. reading), at most one hook is "active". The active hook for the current processing mode will be called when objects of the given type are encountered in the stream. For example, suppose that local and global hooks have been set for a given object type. Then if a read occurs on the stream for which the local hook was set, the local hook will be called, otherwise the global hook will be called. Designating multiple read/write hooks (both local and global) for a selected object does not generate an error. Older or less specific hooks are simply overridden by the more specific or most recently installed hook.

Understanding and creating hooks properly relies on three distinct concepts:

-   **Structural Context** – the criteria for deciding which objects in the stream will be hooked.

-   **Processing Mode** – what is being done when the hook should be called. Hooks will only be called in the corresponding processing mode. For example, if content is being skipped, only skip hooks will be called. If the mode changes to reading, then only read hooks will be called.

-   **Operation** – easily confused with processing mode, the operation is what is done inside the hook, not what is being done when the hook is called.

<span class="nctnt highlight">Note:</span> The difference between processing mode and operation can be very confusing. It is natural to think, for example, "I want to read Bioseq id's" without considering how the stream is being processed. The next natural step is to conclude "I want a read hook" - but that could be incorrect. Instead, one should think "I want to *read* a Bioseq id *inside* a hook". Only then should the processing mode be chosen, and it may not match the operation performed inside the hook. The processing mode should be chosen based on what should be done with the *rest* of the stream and whether or not it's necessary to retain the data *outside* the hook. For example, if you want to read Bioseq id's and don't care about anything else, then you should probably choose the 'skip' processing mode (meaning you would use a skip hook), and *within* the skip hook you would *read* the Bioseq id. Or, if you wanted to read entire Bioseq's for later analysis while automatically building a list of Bioseq id's, you would have to use the 'read' processing mode (and therefore a read hook) to save the data for later analysis. Inside the read hook you would use a read operation (to save the data) and at the same time you would have access to the id for building the list of id's.

There are three main **structural contexts** in which an object might be encountered in a stream:

| Context        | Description                                                                                                                                                                                                                                        |
|----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Object         | When the stream object matches a specified type – for example, the <span class="nctnt ncbi-type">Bioseq</span> type.                                                                                                                               |
| Class Member   | When the stream object matches a specified member of a specified <span class="nctnt ncbi-monospace">SEQUENCE</span> type – for example, the <span class="nctnt ncbi-var">id</span> member of the <span class="nctnt ncbi-type">Bioseq</span> type. |
| Choice Variant | When the stream object matches a specified variant of a specified <span class="nctnt ncbi-monospace">CHOICE</span> type – for example, the <span class="nctnt ncbi-var">std</span> variant of the <span class="nctnt ncbi-type">Date</span> type.  |

Complex structural contexts can be created by nesting the main structural contexts. For example, a [stack path hook](#stack-path-hook) can apply to a specific class member, but only when it is nested inside another specified class member. Stack path hooks also make it possible to hook objects only within a limited level of nesting - for example, hooking only the highest-level Seq-entry's. For more details see the [stack path hook](#stack-path-hook) section.

There are four **processing modes** that can be applied to input/output streams:

| Mode  | Description                                                                              |
|-------|------------------------------------------------------------------------------------------|
| Read  | When objects are parsed from an input stream and a deserialized instance is retained.    |
| Skip  | When objects are parsed from an input stream but a deserialized instance is not retained |
| Copy  | When objects are parsed from an input stream and written directly to an output stream.   |
| Write | When objects are written to an output stream.                                            |

The **operation** is not restricted to a limited set of choices. It can be any application-specific task, as long as that task is compatible with the processing mode. For example, a skip operation can be performed inside a read hook, provided that the skipped content is optional for the object being read. Similarly, a read operation can be performed inside a skip hook. The operation performed inside a hook must preserve the integrity of the hooked object, and must advance the stream all the way through the hooked object and no farther.

Hooks can be installed for all combinations of structural context and processing mode. Each combination has a base class that defines a pure virtual method that must be defined in a derived class to implement the hook – e.g. the <span class="nctnt ncbi-class">CReadObjectHook</span> class defines a pure virtual <span class="nctnt ncbi-func">ReadObject()</span> method. The definition of the overriding method in the derived class is often referred to as "the hook".

|  | Object                                | Class Member                                    | Choice Variant                                      |
|----------------------|---------------------------------------|-------------------------------------------------|-----------------------------------------------------|
| [Read](#read)        | [CReadObjectHook](#creadobjecthook)   | [CReadClassMemberHook](#creadclassmemberhook)   | [CReadChoiceVariantHook](#creadchoicevarianthook)   |
| [Write](#write)      | [CWriteObjectHook](#cwriteobjecthook) | [CWriteClassMemberHook](#cwriteclassmemberhook) | [CWriteChoiceVariantHook](#cwritechoicevarianthook) |
| [Copy](#copy)        | [CCopyObjectHook](#ccopyobjecthook)   | [CCopyClassMemberHook](#ccopyclassmemberhook)   | [CCopyChoiceVariantHook](#ccopychoicevarianthook)   |
| [Skip](#skip)        | [CSkipObjectHook](#cskipobjecthook)   | [CSkipClassMemberHook](#cskipclassmemberhook)   | [CSkipChoiceVariantHook](#cskipchoicevarianthook)   |

In addition, there is a [hook guard](#hook-guard) class, which simplifies creating any of the above hooks. There are also [stack path hook](#stack-path-hook) methods corresponding to each structural context / processing mode combination above, making it easy to create hooks for virtually any conceivable situation.

#### Hook Sample

Here is a complete program that illustrates how to create a read hook for class members (other sample programs are available at <http://www.ncbi.nlm.nih.gov/viewvc/v1/trunk/c++/src/sample/app/serial/>):

    #include <ncbi_pch.hpp>
    #include <objects/general/Date_std.hpp>
    #include <serial/objistr.hpp>
    #include <serial/serial.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    // This class implements a read hook for class members.
    //
    // A read hook is created by passing a new instance of this class to a
    // "set hook" method.  Hooks may be created as global or local.  Global hooks
    // apply to all streams, whereas local hooks are associated with a specific
    // stream.  Thus, the "set hook" methods for creating class member read hooks
    // are:
    //     SetGlobalReadHook()
    //     SetLocalReadHook()
    //
    // This class must override the virtual method ReadClassMember().  See the
    // comment for the ReadClassMember() method below for more details.
    //
    // In principle, multiple instances of this hook class could be used to provide
    // the same hook processing for more than one entity.  However, it is probably
    // best to create a separate class for each "thing" you want to hook and
    // process.
    //
    // You should adopt a meaningful naming convention for your hook classes.
    // In this example, the convention is C<mode><context>Hook_<object>__<member>
    // where:   <mode>=(Read\|Write\|Copy\|Skip)
    //          <context>=(Obj\|CM\|CV)  --  object, class member, or choice variant
    // and hyphens in ASN.1 object types are replaced with underscores.
    //
    // Note:  Since this is a read hook, ReadClassMember() will only be called when
    // reading from the stream.  If the stream is being skipped, ReadClassMember()
    // will not be called.  If you want to use a hook to read a specific type of
    // class member while skipping everything else, use a skip hook and call
    // DefaultRead() from within the SkipClassMember() method.
    //
    // Note: This example is a read hook, which means that the input stream is
    // being read when the hook is called.  Hooks for other processing modes
    // (Write, Skip, and Copy) are similarly created by inheriting from the
    // respecitive base classes.  It is also a ClassMember hook.  Hooks for
    // other structural contexts (Object and ChoiceVariant) a similarly derived
    // from the appropriate base.
    class CDemoHook : public CReadClassMemberHook
    {
    public:
        // Implement the hook method.
        //
        // Once the read hook has been set, ReadClassMember() will be called
        // whenever the specified class member is encountered while
        // reading a hooked input stream.  Without the hook, the encountered
        // class member would have been automatically read.  With the hook, it is
        // now the responsibility of the ReadClassMember() method to remove the
        // class member from the input stream and process it as desired.  It can
        // either read it or skip it to remove it from the stream.  This is
        // easily done by calling DefaultRead() or DefaultSkip() from within
        // ReadClassMember().  Subsequent processing is up to the application.
        virtual void ReadClassMember(CObjectIStream& in,
                                     const CObjectInfoMI& passed_info)
        {
            // Perform any pre-read processing here.
            //NcbiCout << "In ReadClassMember() hook, before reading." << NcbiEndl;

            // You must call DefaultRead() (or perform an equivalent operation)
            // if you want the object to be read into memory.  You could also
            // call DefaultSkip() if you wanted to skip the hooked object while
            // reading everything else.
            DefaultRead(in, passed_info);

            // Perform any post-read processing here.  Once the object has been
            // read, its data can be used for processing. For example, here we dump
            // the read object into the standard output.
            NcbiCout << MSerial_AsnText << passed_info.GetClassObject();
        }
    };

    int main(int argc, char** argv)
    {
        // Create some ASN.1 data that can be parsed by this code sample.
        char asn[] = "Date-std ::= { year 1998 }";

        // Setup an input stream, based on the sample ASN.1.
        CNcbiIstrstream iss(asn);
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, iss));

        ////////////////////////////////////////////////////
        // Create a hook for the 'year' class member of Date-std objects.
        // The year class member was aribtrarily chosen to illustrate the
        // use of hooks - many other entities would work equally well.

        // Get data structures that model the type information for Date-std
        // objects and their 'year' class members.
        // The type information will be used to recognize and forward 'year'
        // class members of Date-std objects found in the stream to the hook.
        CObjectTypeInfo typeInfo = CType<CDate_std>();
        CObjectTypeInfoMI memberInfo = typeInfo.FindMember("year");

        // Set a local hook for Date-std 'year' class members.  This involves
        // creating an instance of the hook class and passing that hook to the
        // "set hook" method, which registers the hook to be called when a hooked
        // type is encountered in the stream.
        memberInfo.SetLocalReadHook(*in, new CDemoHook);


        // The above three statements could be shortened to:
        //CObjectTypeInfo(CType<CDate_std>()).FindMember("year")
        //                                   .SetLocalReadHook(*in, new CDemoHook);


        // Read from the input stream, storing data in the object.  At this point,
        // the hook is in place so simply reading from the input stream will
        // cause the hook to be triggered whenever the 'year' class member is
        // encountered.
        CDate_std my_date;
        *in >> my_date;

        return 0;
    }

#### Read mode hooks

All of the different structural contexts in which an object might be encountered on an input stream can be reduced to three cases:

-   as a stand-alone object

-   as a data member of a containing object

-   as a variant of a <span class="nctnt ncbi-monospace">choice</span> object

Hooks can be installed for each of the above contexts, depending on the desired level of specificity. Corresponding to these contexts, three abstract base classes provide the foundations for deriving new <span class="nctnt ncbi-monospace">Read</span> hooks:

-   <span class="nctnt ncbi-class">CReadObjectHook</span>

-   <span class="nctnt ncbi-class">CReadClassMemberHook</span>

-   <span class="nctnt ncbi-class">CReadChoiceVariantHook</span>

Each of these base hook classes exists only to define a pure virtual <span class="nctnt ncbi-func">Read</span> method, which can then be implemented (in a derived subclass) to install the desired type of read hook. If the goal is to apply the new <span class="nctnt ncbi-func">Read</span> method in all contexts, then the new hook should be derived from the <span class="nctnt ncbi-class">CReadObjectHook</span> class, and registered with the object's static type information object. For example, to install a new <span class="nctnt ncbi-class">CReadObjectHook</span> for a <span class="nctnt ncbi-class">CBioseq</span>, one might use:

    CObjectTypeInfo(CBioseq::GetTypeInfo()).
        SetLocalReadHook(*in, myReadBioseqHook);

Another way of installing hooks of any type (read/write/copy, object/member/variant) is provided by <span class="nctnt ncbi-class">CObjectHookGuard</span> class described below.

Alternatively, if the desired behavior is to trigger the specialized <span class="nctnt ncbi-func">Read</span> method only when the object occurs as a data member of a particular containing class, then the new hook should be derived from the <span class="nctnt ncbi-class">CReadClassMemberHook</span>, and registered with that member's type information object:

    CObjectTypeInfo(CBioseq::GetTypeInfo()).
        FindMember("Seq-inst").SetLocalReadHook(*in, myHook);

Similarly, one can install a read hook that will only be triggered when the object occurs as a choice variant:

    CObjectTypeInfo(CSeq_entry::GetTypeInfo()).
        FindVariant("Bioseq").SetLocalReadHook(*in, myReadBioseqHook);

The new hook classes for these examples should be derived from <span class="nctnt ncbi-class">CReadObjectHook</span>, <span class="nctnt ncbi-class">CReadClassMemberHook</span>, and <span class="nctnt ncbi-class">CReadChoiceVariantHook</span>, respectively. In the first case, all occurrences of <span class="nctnt ncbi-class">CBioseq</span> on any input stream will trigger the new <span class="nctnt ncbi-func">Read</span> method. In contrast, the third case installs this new <span class="nctnt ncbi-func">Read</span> method to be triggered only when the <span class="nctnt ncbi-class">CBioseq</span> occurs as a choice variant in a <span class="nctnt ncbi-class">CSeq\_entry</span> object.

All of the virtual <span class="nctnt ncbi-func">Read</span> methods take two arguments: a <span class="nctnt ncbi-class">CObjectIStream</span> and a reference to a [CObjectInfo](#cobjectinfo). For example, the <span class="nctnt ncbi-class">CReadObjectHook</span> class declares the <span class="nctnt ncbi-func">ReadObject()</span> method as:

    virtual void ReadObject(CObjectIStream& in,
                            const CObjectInfo& object) = 0;

The <span class="nctnt ncbi-func">ReadClassMember</span> and <span class="nctnt ncbi-func">ReadChoiceVariant</span> hooks differ from the <span class="nctnt ncbi-func">ReadObject</span> hook class, in that the second argument to the virtual <span class="nctnt ncbi-func">Read</span> method is an iterator, pointing to the object type information for a sequence member or choice variant respectively.

In summary, to install a read hook for an object type:

derive a new class from the appropriate hook class:

-   if the hook should be called regardless of the structural context in which the target object occurs, use the <span class="nctnt ncbi-class">CReadObjectHook</span> class.

-   if the target object occurs as a sequence member, use the <span class="nctnt ncbi-class">CReadClassMemberHook</span> class.

-   if the target object occurs as a choice variant, use the <span class="nctnt ncbi-class">CReadChoiceVariant Hook</span> class.

implement the virtual <span class="nctnt ncbi-func">Read</span> method for the new class.

install the hook, using the <span class="nctnt ncbi-func">SetLocalReadHook()</span> method defined in

-   <span class="nctnt ncbi-class">CObjectTypeInfo</span> for a <span class="nctnt ncbi-class">CReadObjectHook</span>

-   <span class="nctnt ncbi-class">CMemberInfo</span> for a <span class="nctnt ncbi-class">CReadClassMemberHook</span>

-   <span class="nctnt ncbi-class">CVariantInfo</span> for a <span class="nctnt ncbi-class">CReadChoiceVariantHook</span>

or use <span class="nctnt ncbi-class">CObjectHookGuard</span> class to install any of these hooks.

In many cases you will need to read the hooked object and do some special processing, or to skip the entire object. To simplify object reading or skipping all base hook classes have <span class="nctnt ncbi-func">DefaultRead()</span> and <span class="nctnt ncbi-func">DefaultSkip()</span> methods taking the same arguments as the user provided ReadXXXX() methods. Thus, to read a bioseq object from a hook:

    void CMyReadObjectHook::ReadObject(CObjectIStream& in,
                                       const CObjectInfo& object)
    {
        DefaultRead(in, object);
        // Do some user-defined processing of the bioseq
    }

Note that from a choice variant hook you can not skip stream data -- this could leave the choice object in an uninitialized state. For this reason the CReadChoiceVariantHook class has no DefaultSkip() method.

##### Read Object Hook Sample

A read object hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/general/Date_std.hpp>
    #include <serial/objistr.hpp>
    #include <serial/serial.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook : public CReadObjectHook
    {
    public:
        virtual void ReadObject(CObjectIStream& strm,
                                const CObjectInfo& passed_info)
        {
            DefaultRead(strm, passed_info);
        }
    };

    int main(int argc, char** argv)
    {
        char asn[] = "Date-std ::= { year 1998 }";
        CNcbiIstrstream iss(asn);
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, iss));

        CObjectTypeInfo(CType<CDate_std>()).SetLocalReadHook(*in, new CDemoHook());

        CDate_std my_date;
        *in >> my_date;

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCReadObjectHook.html) for more information.

##### Read Class Member Hook Sample

A read class member hook can be created very much like other hooks. For an example, see the [hook sample](#hook-sample).

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCReadClassMemberHook.html) for more information.

##### Read Choice Variant Hook Sample

A read choice variant hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/general/Date.hpp>
    #include <serial/objistr.hpp>
    #include <serial/serial.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook : public CReadChoiceVariantHook
    {
    public:
        virtual void ReadChoiceVariant(CObjectIStream& strm,
                                       const CObjectInfoCV& passed_info)
        {
            DefaultRead(strm, passed_info);
        }
    };

    int main(int argc, char** argv)
    {
        char asn[] = "Date ::= str \"late-spring\"";
        CNcbiIstrstream iss(asn);
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, iss));

        CObjectTypeInfo(CType<CDate>()).FindVariant("str")
                                       .SetLocalReadHook(*in, new CDemoHook);

        CDate my_date;
        *in >> my_date;

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCReadChoiceVariantHook.html) for more information.

#### Write mode hooks

The <span class="nctnt ncbi-monospace">Write</span> hook classes parallel the <span class="nctnt ncbi-monospace">Read</span> hook classes, and again, we have three base classes:

-   <span class="nctnt ncbi-class">CWriteObjectHook</span>

-   <span class="nctnt ncbi-class">CWriteClassMemberHook</span>

-   <span class="nctnt ncbi-class">CWriteChoiceVariantHook</span>

These classes define the pure virtual methods:

    CWriteObjectHook::WriteObject(CObjectOStream&,
        const CConstObjectInfo& object) = 0;

    CWriteClassMemberHook::WriteClassMember(CObjectOStream&,
        const CConstObjectInfoMI& member) = 0;

    CWriteChoiceVariantHook::WriteChoiceVariant(CObjectOStream&,
        const CConstObjectInfoCV& variant) = 0;

Like the read hooks, your derived write hooks can be installed by invoking the <span class="nctnt ncbi-func">SetLocalWriteObjectHook()</span> methods for the appropriate type information objects. Corresponding to the examples for read hooks then, we would have:

    CObjectTypeInfo(CBioseq::GetTypeInfo()).
        SetLocalWriteHook(*in, myWriteBioseqHook);

    CObjectTypeInfo(CBioseq::GetTypeInfo()).
        FindMember("Seq-inst").SetLocalWriteHook(*in, myWriteSeqinstHook);

    CObjectTypeInfo(CSeq_entry::GetTypeInfo()).
        FindVariant("Bioseq").SetLocalWriteHook(*in, myWriteBioseqHook);

<span class="nctnt ncbi-class">CObjectHookGuard</span> class provides is a simple way to install write hooks.

##### Write Object Hook Sample

A write object hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/biblio/Cit_art.hpp>
    #include <serial/objectio.hpp>
    #include <serial/objistr.hpp>
    #include <serial/objostr.hpp>
    #include <serial/serial.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook : public CWriteObjectHook
    {
    public:
        virtual void WriteObject(CObjectOStream& out,
                                 const CConstObjectInfo& passed_info)
        {
            DefaultWrite(out, passed_info);
        }
    };

    int main(int argc, char** argv)
    {
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, "if"));
        auto_ptr<CObjectOStream> out(CObjectOStream::Open(eSerial_AsnText, "of"));

        CObjectTypeInfo(CType<CCit_art>()).SetLocalWriteHook(*out, new CDemoHook);

        CCit_art article;
        *in >> article;
        *out << article;

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCWriteObjectHook.html) for more information.

##### Write Class Member Hook Sample

A write class member hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/biblio/Auth_list.hpp>
    #include <objects/biblio/Cit_art.hpp>
    #include <serial/objectio.hpp>
    #include <serial/objistr.hpp>
    #include <serial/objostr.hpp>
    #include <serial/serial.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook: public CWriteClassMemberHook
    {
    public:
        virtual void WriteClassMember(CObjectOStream& out,
                                      const CConstObjectInfoMI& passed_info)
        {
            DefaultWrite(out, passed_info);
        }
    };

    int main(int argc, char** argv)
    {
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, "if"));
        auto_ptr<CObjectOStream> out(CObjectOStream::Open(eSerial_AsnText, "of"));

        CObjectTypeInfo(CType<CAuth_list>())
            .FindMember("names")
            .SetLocalWriteHook(*out, new CDemoHook);

        CCit_art article;
        *in >> article;
        *out << article;

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCWriteClassMemberHook.html) for more information.

##### Write Choice Variant Hook Sample

A write choice variant hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/biblio/Auth_list.hpp>
    #include <objects/biblio/Cit_art.hpp>
    #include <serial/objectio.hpp>
    #include <serial/objistr.hpp>
    #include <serial/objostr.hpp>
    #include <serial/serial.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook : public CWriteChoiceVariantHook
    {
    public:
        virtual void WriteChoiceVariant(CObjectOStream& out,
                                        const CConstObjectInfoCV& passed_info)
        {
            DefaultWrite(out, passed_info);
        }
    };

    int main(int argc, char** argv)
    {
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, "if"));
        auto_ptr<CObjectOStream> out(CObjectOStream::Open(eSerial_AsnText, "of"));

        (*CObjectTypeInfo(CType<CAuth_list>()).FindMember("names"))
            .GetPointedType()
            .FindVariant("std")
            .SetLocalWriteHook(*out, new CDemoHook);

        CCit_art article;
        *in >> article;
        *out << article;

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCWriteChoiceVariantHook.html) for more information.

#### Copy mode hooks

As with the <span class="nctnt ncbi-monospace">Read</span> and <span class="nctnt ncbi-monospace">Write</span> hook classes, there are three base classes which define the following <span class="nctnt ncbi-monospace">Copy</span> methods:

    CCopyObjectHook::CopyObject(CObjectStreamCopier& copier,
        const CObjectTypeInfo& object) = 0;

    CCopyClassMemberHook::CopyClassMember(CObjectStreamCopier& copier,
        const CObjectTypeInfoMI& member) = 0;

    CCopyChoiceVariantHook::CopyChoiceVariant(CObjectStreamCopier& copier,
        const CObjectTypeInfoCV& variant) = 0;

Newly derived copy hooks can be installed by invoking the <span class="nctnt ncbi-func">SetLocalCopyObjectHook()</span> method for the appropriate type information object. The other way of installing hooks is described below in the <span class="nctnt ncbi-class">CObjectHookGuard</span> section.

To do default copying of an object in the overloaded hook method each of the base copy hook classes has a <span class="nctnt ncbi-func">DefaultCopy()</span> method.

##### Copy Object Hook Sample

A copy object hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/biblio/Cit_art.hpp>
    #include <serial/objcopy.hpp>
    #include <serial/objectio.hpp>
    #include <serial/objistr.hpp>
    #include <serial/objostr.hpp>
    #include <serial/serial.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook : public CCopyObjectHook
    {
    public:
        virtual void CopyObject(CObjectStreamCopier& copier,
                                const CObjectTypeInfo& passed_info)
        {
            DefaultCopy(copier, passed_info);
        }
    };

    int main(int argc, char** argv)
    {
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, "if"));
        auto_ptr<CObjectOStream> out(CObjectOStream::Open(eSerial_AsnText, "of"));
        CObjectStreamCopier copier(*in, *out);

        CObjectTypeInfo(CType<CCit_art>())
            .SetLocalCopyHook(copier, new CDemoHook());

        copier.Copy(CType<CCit_art>());

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCCopyObjectHook.html) for more information.

##### Copy Class Member Hook Sample

A copy class member hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/seq/Bioseq.hpp>
    #include <objects/seqset/Seq_entry.hpp>
    #include <serial/objcopy.hpp>
    #include <serial/objectio.hpp>
    #include <serial/objistr.hpp>
    #include <serial/objostr.hpp>
    #include <serial/serial.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook : public CCopyClassMemberHook
    {
    public:
        virtual void CopyClassMember(CObjectStreamCopier& copier,
                                     const CObjectTypeInfoMI& passed_info)
        {
            DefaultCopy(copier, passed_info);
        }
    };

    int main(int argc, char** argv)
    {
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, "if"));
        auto_ptr<CObjectOStream> out(CObjectOStream::Open(eSerial_AsnText, "of"));
        CObjectStreamCopier copier(*in, *out);

        CObjectTypeInfo(CType<CBioseq>())
            .FindMember("annot")
            .SetLocalCopyHook(copier, new CDemoHook());

        copier.Copy(CType<CBioseq>());

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCCopyClassMemberHook.html) for more information.

##### Copy Choice Variant Hook Sample

A copy choice variant hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/biblio/Auth_list.hpp>
    #include <objects/biblio/Cit_art.hpp>
    #include <serial/objcopy.hpp>
    #include <serial/objectio.hpp>
    #include <serial/objistr.hpp>
    #include <serial/objostr.hpp>
    #include <serial/serial.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook : public CCopyChoiceVariantHook
    {
    public:
        virtual void CopyChoiceVariant(CObjectStreamCopier& copier,
                                       const CObjectTypeInfoCV& passed_info)
        {
            DefaultCopy(copier, passed_info);
        }
    };

    int main(int argc, char** argv)
    {
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, "if"));
        auto_ptr<CObjectOStream> out(CObjectOStream::Open(eSerial_AsnText, "of"));
        CObjectStreamCopier copier(*in, *out);

        (*CObjectTypeInfo(CType<CAuth_list>()).FindMember("names"))
            .GetPointedType()
            .FindVariant("std")
            .SetLocalCopyHook(copier, new CDemoHook);

        copier.Copy(CType<CCit_art>());

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCCopyChoiceVariantHook.html) for more information.

#### Skip mode hooks

As with the <span class="nctnt ncbi-monospace">Read</span> and <span class="nctnt ncbi-monospace">Write</span> hook classes, there are three base classes which define the following <span class="nctnt ncbi-monospace">Skip</span> methods:

    CSkipObjectHook::SkipObject(CObjectIStream& in,
        const CObjectTypeInfo& object) = 0;

    CSkipClassMemberHook::SkipClassMember(CObjectIStream& in,
        const CObjectTypeInfoMI& member) = 0;

    CSkipChoiceVariantHook::SkipChoiceVariant(CObjectIStream& in,
        const CObjectTypeInfoCV& variant) = 0;

Newly derived skip hooks can be installed by invoking the <span class="nctnt ncbi-func">SetLocalSkipObjectHook()</span> method for the appropriate type information object. The other way of installing hooks is described below in the <span class="nctnt ncbi-class">CObjectHookGuard</span> section.

The <span class="nctnt ncbi-class">CSkipObjectHook</span> class has a <span class="nctnt ncbi-func">DefaultSkip()</span> method, like the base classes for the other processing modes, but for historical reasons <span class="nctnt ncbi-func">DefaultSkip()</span> methods were not defined for the <span class="nctnt ncbi-class">CSkipClassMemberHook</span> and <span class="nctnt ncbi-class">CSkipChoiceVaraintHook</span> classes. Nevertheless, achieving the same result is easily accomplished – for example:

    class CMySkipClassMemberHook : public CSkipClassMemberHook
    {
    public:
        virtual void SkipClassMember(CObjectIStream& in,
                                     const CObjectTypeInfoMI& member)
        {
            in.SkipObject(*member);
        }
    };

##### Skip Object Hook Sample

A skip object hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/biblio/Cit_art.hpp>
    #include <serial/objistr.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook : public CSkipObjectHook
    {
    public:
        virtual void SkipObject(CObjectIStream& in,
                                const CObjectTypeInfo& passed_info)
        {
        }
    };

    int main(int argc, char** argv)
    {
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, "if"));

        CObjectTypeInfo(CType<CCit_art>()).SetLocalSkipHook(*in, new CDemoHook);

        in->Skip(CType<CCit_art>());

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSkipObjectHook.html) for more information.

##### Skip Class Member Hook Sample

A skip class member hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/biblio/Auth_list.hpp>
    #include <objects/biblio/Cit_art.hpp>
    #include <serial/objistr.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook : public CSkipClassMemberHook
    {
    public:
        virtual void SkipClassMember(CObjectIStream& in,
                                     const CObjectTypeInfoMI& passed_info)
        {
            in.SkipObject(*passed_info);
        }
    };

    int main(int argc, char** argv)
    {
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, "if"));

        CObjectTypeInfo(CType<CAuth_list>())
            .FindMember("names")
            .SetLocalSkipHook(*in, new CDemoHook);

        in->Skip(CType<CCit_art>());

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSkipClassMemberHook.html) for more information.

##### Skip Choice Variant Hook Sample

A skip choice variant hook can be created very much like other hooks. For example, the executable lines in the [hook sample](#hook-sample), can be replaced with:

    #include <ncbi_pch.hpp>
    #include <objects/biblio/Imprint.hpp>
    #include <objects/general/Date.hpp>
    #include <serial/objistr.hpp>

    USING_NCBI_SCOPE;
    USING_SCOPE(ncbi::objects);

    class CDemoHook : public CSkipChoiceVariantHook
    {
    public:
        virtual void SkipChoiceVariant(CObjectIStream& in,
                                       const CObjectTypeInfoCV& passed_info)
        {
            in.SkipObject(*passed_info);
        }
    };

    int main(int argc, char** argv)
    {
        char asn[] = "Imprint ::= { date std { year 2010 } }";
        CNcbiIstrstream iss(asn);
        auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, iss));

        CObjectTypeInfo(CType<CDate>()).FindVariant("std")
                                       .SetLocalSkipHook(*in, new CDemoHook());

        in->Skip(CType<CImprint>());

        return 0;
    }

See the [class documentation](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSkipChoiceVariantHook.html) for more information.

#### The <span class="nctnt ncbi-class">CObjectHookGuard</span> class

To simplify hooks usage <span class="nctnt ncbi-class">CObjectHookGuard</span> class may be used. It's a template class: the template parameter is the class to be hooked (in case of member or choice variant hooks it's the parent class of the member).

The CObjectHookGuard class has several constructors for installing different hook types. The last argument to all constructors is a stream pointer. By default the pointer is NULL and the hook is intalled as a global one. To make the hook stream-local pass the stream to the guard constructor.

-   Object read/write hooks:<br/><span class="nctnt ncbi-code">CObjectHookGuard(CReadObjectHook& hook,</span><br/><span class="nctnt ncbi-code"> CObjectIStream\* in = 0);</span><br/><span class="nctnt ncbi-code">CObjectHookGuard(CWriteObjectHook& hook,</span><br/><span class="nctnt ncbi-code"> CObjectOStream\* out = 0);</span>

-   Class member read/write hooks:<br/><span class="nctnt ncbi-code">CObjectHookGuard(string id,</span><br/><span class="nctnt ncbi-code"> CReadClassMemberHook& hook,</span><br/><span class="nctnt ncbi-code"> CObjectIStream\* in = 0);</span><br/><span class="nctnt ncbi-code">CObjectHookGuard(string id,</span><br/><span class="nctnt ncbi-code"> CWriteClassMemberHook& hook,</span><br/><span class="nctnt ncbi-code"> CObjectOStream\* out = 0);</span>

The string "id" argument is the name of the member in ASN.1 specification for generated classes.

-   Choice variant read/write hooks:<br/><span class="nctnt ncbi-code">CObjectHookGuard(string id,</span><br/><span class="nctnt ncbi-code"> CReadChoiceVariantHook& hook,</span><br/><span class="nctnt ncbi-code"> CObjectIStream\* in = 0);</span><br/><span class="nctnt ncbi-code">CObjectHookGuard(string id,</span><br/><span class="nctnt ncbi-code"> CWriteChoiceVariantHook& hook,</span><br/><span class="nctnt ncbi-code"> CObjectOStream\* out = 0);</span>

The string "id" argument is the name of the variant in ASN.1 specification for generated classes.

The guard's destructor will uninstall the hook. Since all hook classes are derived from CObject and stored as CRef\<\>-s, the hooks are destroyed automatically when uninstalled. For this reason it's recommended to create hook objects on heap.

#### Stack Path Hooks

When an object is serialized or deserialized, a string called the stack path is created internally to track the structural context of the current location. The stack path starts with the type name of the top-level data object. While each sub-object is processed, a '<span class="nctnt ncbi-monospace">.</span>' and the sub-object name are "pushed on the stack".

Stack path hooks enable you to hook complex structural contexts by nesting the main structural contexts - for example, a specific nesting pattern of class members. Stack path hooks also make it possible to hook objects only within a limited level of nesting - for example, the [hooks\_highest\_se\_objs](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/sample/app/serial/hooks_highest_se_objs.cpp) sample program shows how to hook only the highest-level Seq-entry's.

An example of a possible stack path string is:

    Seq-entry.set.seq-set.seq.annot.data.ftable.data.pub.pub.article

Hooks based on the stack path can be created if you need to specify a more complex structural context for when a hook should be called. More complex, that is, than the "object", "class member", and "choice variant" contexts discussed in earlier sections. For example, "I want to hook the reading of objects named 'title' when and only when they are contained by objects named 'book', not all occurrences of 'title' objects", or, "I want to hook the reading of all sequence members named 'title' in all objects, not only in a specific one". The serial library makes it possible to set hooks for such structural contexts by passing a stack path mask to various "SetHook" methods. When the stack path string for the object being processed matches the stack path mask, the hook will be called.

The general form of the stack path mask is:

    TypeName.Member1.Member2.HookedMember

More formally:

    StackPathMask ::= (TypeName \| Wildcard) ('.' (MemberName \| Wildcard))+

Here <span class="nctnt ncbi-monospace">TypeName</span> and <span class="nctnt ncbi-monospace">MemberName</span> are strings; '<span class="nctnt ncbi-monospace">.</span>' separates path elements; and <span class="nctnt ncbi-monospace">Wildcard</span> is defined as:

    Wildcard ::= ('?' \| '*')

The question mark means "match exactly one path element with any name", while the asterisk means "match one or more path elements with any names".

An example of a possible stack path mask is:

    *.article.*.authors

<span class="nctnt highlight">Note:</span> The first element of the stack path mask must be either a wildcard or the type of the top-level object in the stream. Type names are not permitted anywhere but the first element, which makes stack path masks like "<span class="nctnt ncbi-monospace">\*.Cit-book.\*.date</span>" invalid (ASN.1 type names begin with uppercase while member names begin with lowercase).

As with regular serialization hooks, it is possible to install a path hook for a specific object:

    CObjectTypeInfo(CBioseq::GetTypeInfo()).
        SetPathReadHook(in, path, myReadBioseqHook);

a member of a sequence object:

    CObjectTypeInfo(CBioseq::GetTypeInfo()).FindMember("inst").
        SetPathReadHook(in, path, myReadSeqinstHook);

or a variant of a choice object:

    CObjectTypeInfo(CSeq_entry::GetTypeInfo()).FindVariant("seq").
        SetPathReadHook(in, path, myReadBioseqHook);

Here <span class="nctnt ncbi-var">in</span> is a pointer to an input object stream. If it is equal to zero, the hook will be installed globally, otherwise - for that particular stream.

In addition, it is possible to install path hooks directly in object streams without specifying an ASN.1 type. For example, to install a read hook on all string objects named <span class="nctnt ncbi-var">last-name</span>, one could use either this:

    CObjectTypeInfo(CStdTypeInfo<string>::GetTypeInfo()).
        SetPathReadHook(in,"*.last-name",myObjHook);

or this:

    in->SetPathReadObjectHook("*.last-name", myObjHook);

Setting path hooks directly in streams also makes it possible to differentiate between <span class="nctnt ncbi-var">last-name</span> being a sequence member and choice variant. So, for example:

    in->SetPathReadMemberHook("*.last-name", myMemHook);

will hook sequence members and not choice variants, while:

    in->SetPathReadVariantHook("*.last-name", myVarHook);

will hook choice variants and not sequence members.

Stack path hooks can be removed by passing <span class="nctnt ncbi-macro">NULL</span> instead of a hook pointer to the various "SetHook" methods.

#### Hooking anonymous objects

Certain ASN.1 constructs result in anonymous objects. For example, in this ASN.1 specification:

    Bioseq-set ::= SEQUENCE {
        -- skipping other class members
        seq-set SEQUENCE OF Seq-entry

the seq-set class member contains anonymous Seq-entry objects. You can hook the complete sequence using the name "seq-set", but there is no name to use to hook the individual Seq-entry elements of the sequence.

The solution is to hook the seq-set container and iterate through the elements using the <span class="nctnt ncbi-class">CIStreamContainerIterator</span> class. For example:

    class CSkipMemberHook__Bioseq_set : public CSkipClassMemberHook
    {
    public:
        virtual void SkipClassMember(CObjectIStream& stream,
                                     const CObjectTypeInfoMI& info)
        {
            // The whole container is hooked, so we have to iterate
            // to access the contained elements.
            CIStreamContainerIterator iter(stream, info.GetMemberType());
            for ( ; iter; ++iter) {
                CSeq_entry entry;
                iter >> entry;  // read individual elements
                Process(entry); // process as desired
            }
        }
    };
    ...
            // This is how to hook the container:
            in->SetPathSkipMemberHook("Bioseq-set.seq-set",
                                      new CSkipMemberHook__Bioseq_set());
    ...
            // Skip through the stream, triggering the hook:
            in->Skip(CType<CBioseq_set>());

<span class="nctnt highlight">Note:</span> Hooking ASN.1 "SET OF" works the same way as "SEQUENCE OF".

### Stream Iterators

When working with a stream, it is sometimes convenient to be able to read or write data elements directly, bypassing the standard data storage mechanism. For example, when reading a large container object, the purpose could be to process its elements. It is possible to read everything at once, but this could require a lot of memory to store the data in. An alternative approach, which greatly reduces the amount of required memory, could be to read elements one by one, process them as they arrive, and then discard. Or, when writing a container, one could construct it in memory only partially, and then add missing elements 'on the fly' - where appropriate. To make it possible, the SERIAL library introduces <span class="nctnt ncbi-monospace">stream iterators</span>. Needless to say, the most convenient way of using this mechanism is in read/write hooks.

SERIAL library defines the following stream iterator classes: <span class="nctnt ncbi-class">CIStreamClassMemberIterator</span> and <span class="nctnt ncbi-class">CIStreamContainerIterator</span> for input streams, and <span class="nctnt ncbi-class">COStreamClassMember</span> and <span class="nctnt ncbi-class">COStreamContainer</span> for output ones.

Reading a container could look like this:

    for ( CIStreamContainerIterator it(in, containerType); it; ++it ) {
          CElementClass element;
          it >> element;
    }

Writing - like this:

    set<CElementClass> container;  // your container
    ...
    COStreamContainer osc(out, containerType);
    ITERATE(set<CElementClass>, it, container) {
        const CElementClass& element = *it;
        osc << element;
    }

For more examples of using stream iterators please refer to [asn2asn](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/asn2asn/asn2asn.cpp) sample application.

### The <span class="nctnt ncbi-class">ByteBlock</span> and <span class="nctnt ncbi-class">CharBlock</span> classes

<span class="nctnt ncbi-class">CObject[IO]Stream::ByteBlock</span> class may be used for non-standard processing of an OCTET STRING data, e.g. from a read/write hooks. The <span class="nctnt ncbi-class">CObject[IO]Stream::CharBlock</span> class has almost the same functionality, but may be used for VisibleString data processing.

An example of using ByteBlock or CharBlock classes is generating data on-the-fly in a write hook. To use block classes:

Initialize the block variable with an i/o stream and, in case of output stream, the length of the block.

Use Read()/Write() functions to process block data

Close the block with the End() function

Below is an example of using <span class="nctnt ncbi-class">CObjectOStream::ByteBlock</span> in an object write hook for non-standard data processing. Note, that ByteBlock and CharBlock classes read/write data only. You should also provide some code for writing class' and members' tags.

Since OCTET STRING and VisibleString in the NCBI C++ Toolkit are implemented as <span class="nctnt ncbi-class">vector\<char\></span> and <span class="nctnt ncbi-class">string</span> classes, which have no serailization type info, you can not install a read or write hook for these classes. The example also demonstrates how to process members of these types using the containing class hook. Another example of using CharBlock with write hooks can be found in [test\_serial.cpp](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/serial/test/test_serial.cpp) application.

    void CWriteMyObjectHook::WriteObject(CObjectOStream& out,
                                         const CConstObjectInfo& object)
    {
        const CMyObject& obj = *reinterpret_cast<const CMyObject*>
            (object.GetObjectPtr());
        if ( NothingToProcess(obj) ) {
            // No special processing - use default write method
            DefaultWrite(out, object);
            return;
        }
        // Write object open tag
        out.BeginClass(object.GetClassTypeInfo());
        // Iterate object members
        for (CConstObjectInfo::CMemberIterator member =
            object.BeginMembers(); member; ++member) {
            if ( NeedProcessing(member) ) {
                // Write the special member manually
                out.BeginClassMember(member.GetMemberInfo()->GetId());
                // Start byte block, specify output stream and block size
                size_t length = GetRealDataLength(member);
                CObjectOStream::ByteBlock bb(out, length);
                // Processing and output
                for (int i = 0; i < length; ) {
                    char* buf;
                    int buf_size;
                    // Assuming ProcessData() generates the data from "member",
                    // starting from position "i" and stores the data to "buf"
                    ProcessData(member, i, &buf_size, &buf);
                    i += buf_size;
                    bb.Write(buf, buf_size);
                }
            }
            // Close the byte block
            bb.End();
            // Close the member
            out.EndClassMember();
        }
        else {
            // Default writer for members without special processing
            if ( member.IsSet() )
                out.WriteClassMember(member);
        }
        // Close the object
        out.EndClass();
    }

### NCBI C++ Toolkit Network Service (RPC) Clients

The following topics are discussed in this section:

-   [Introduction and Use](#introduction-and-use)

-   [Implementation Details](#implementation-details)

#### Introduction and Use

The C++ Toolkit now contains [datatool](ch_app.html#ch_app.datatool)-generated classes for certain ASN.1-based network services: at the time of this writing, <span class="nctnt ncbi-monospace">Entrez2</span>, <span class="nctnt ncbi-monospace">ID1</span>, and <span class="nctnt ncbi-monospace">MedArch</span>. (There is also an independently written class for the <span class="nctnt ncbi-monospace">Taxon1</span> service, [CTaxon1](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CTaxon1&d=C), which this page does not discuss further.) All of these classes, declared in headers named <span class="nctnt ncbi-path">objects/.../client(\_).hpp</span>, inherit certain useful properties from the base template [CRPCClient\<\>](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CRPCClient&d=C):

-   They normally defer connection until the first actual query, and disconnect automatically when destroyed, but let users request either action explicitly.

-   They are designed to be thread-safe (but, at least for now, maintain only a single connection per instance, so forming pools may be appropriate).

The usual interface to these classes is through a family of methods named <span class="nctnt ncbi-func">AskXxx</span>, each of which takes a request of an appropriate type and an optional pointer to an object that will receive the full reply and returns the corresponding reply choice. For example, <span class="nctnt ncbi-func">CEntrez2Client::AskEval\_boolean</span> takes a request of type <span class="nctnt ncbi-type">const CEntrez2\_eval\_boolean&</span> and an optional pointer of type <span class="nctnt ncbi-type">CEntrez2\_reply\*</span>, and returns a reply of type <span class="nctnt ncbi-type">CRef\<CEntrez2\_boolean\_reply\></span>. All of these methods automatically detect server-reported errors or unexpected reply choices, and throw appropriate exceptions when they occur. There are also lower-level methods simply named <span class="nctnt ncbi-func">Ask</span>, which may come in handy if you do not know what kind of query you will need to make.

In addition to these standard methods, there are certain class-specific methods: <span class="nctnt ncbi-class">CEntrez2Client</span> adds <span class="nctnt ncbi-func">GetDefaultRequest</span> and <span class="nctnt ncbi-func">SetDefaultRequest</span> for dealing with those fields of <span class="nctnt ncbi-type">Entrez2-request</span> besides <span class="nctnt ncbi-var">request</span> itself, and <span class="nctnt ncbi-class">CID1Client</span> adds <span class="nctnt ncbi-func">{Get,Set}AllowDeadEntries</span> (off by default) to control how to handle the result choice <span class="nctnt ncbi-var">gotdeadseqentry</span>.

#### Implementation Details

In order to get [datatool](ch_app.html#ch_app.datatool) to generate classes for a service, you must add some settings to the corresponding <span class="nctnt ncbi-path">modulename.def</span> file. Specifically, you must set <span class="nctnt ncbi-var">[-]clients</span> to the relevant base file name (typically <span class="nctnt ncbi-monospace">service</span><span class="nctnt ncbi-code">\_client</span>), and add a correspondingly named section containing the entries listed in [Table 1](#table-1). (If a single specification defines multiple protocols for which you would like <span class="nctnt ncbi-app">datatool</span> to generate classes, you may list multiple client names, separated by spaces.)

Table 1. Network Service Client Generation Parameters

| Name                                                   | Value                                                                                                                                                                                                                                                                                                                                                                                                                |
|--------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span class="nctnt ncbi-var">class</span> (REQUIRED)   | C++ class name to use.                                                                                                                                                                                                                                                                                                                                                                                               |
| <span class="nctnt ncbi-var">service</span>            | Named service to connect to; if you do not define this, you will need to override <span class="nctnt ncbi-func">x\_Connect</span> in the user class.                                                                                                                                                                                                                                                                 |
| <span class="nctnt ncbi-var">serialformat</span>       | Serialization format: normally <span class="nctnt ncbi-monospace">AsnBinary</span>, but <span class="nctnt ncbi-monospace">AsnText</span> and <span class="nctnt ncbi-monospace">Xml</span> are also legal.                                                                                                                                                                                                          |
| <span class="nctnt ncbi-var">request</span> (REQUIRED) | ASN.1 type for requests; may include a module name, a field name (as with <span class="nctnt ncbi-monospace">Entrez2</span>), or both. Must be a CHOICE.                                                                                                                                                                                                                                                             |
| <span class="nctnt ncbi-var">reply</span> (REQUIRED)   | ASN.1 type for replies, as above.                                                                                                                                                                                                                                                                                                                                                                                    |
| <span class="nctnt ncbi-var">reply.choice\_name</span> | Reply choice appropriate for requests of type <span class="nctnt ncbi-var">choice\_name</span>; defaults to <span class="nctnt ncbi-var">choice\_name</span> as well, and determines the return type of <span class="nctnt ncbi-func">AskChoice\_name</span>. May be set to <span class="nctnt ncbi-monospace">special</span> to suppress automatic method generation and let the user class handle the whole thing. |

### Verification of Class Member Initialization

When serializing an object, it is important to verify that all mandatory primitive data members (e.g. strings, integers) are given a value. The NCBI C++ Toolkit implements this through a data initialization verification mechanism. In this mechanism, the value itself is not validated; that is, it still could be semantically incorrect. The purpose of the verification is only to make sure that the member has been assigned some value. The verification also provides for a possibility to check whether the object data member has been initialized or not. This could be useful when constructing such objects in memory.

From this perspective, each data member (XXX) of a serial object generated by <span class="nctnt ncbi-app">DATATOOL</span> from an ASN or XML specification has the <span class="nctnt ncbi-func">IsSetXXX()</span> and <span class="nctnt ncbi-func">CanGetXXX()</span> methods. Also, input and output streams have <span class="nctnt ncbi-func">SetVerifyData()</span> and <span class="nctnt ncbi-func">GetVerifyData()</span> methods. The purpose of <span class="nctnt ncbi-func">CanGetXXX()</span> method is to answer the question whether it is safe or not to call the corresponding <span class="nctnt ncbi-func">GetXXX()</span>. The meaning of <span class="nctnt ncbi-func">IsSetXXX()</span> is whether the data member has been assigned a value explicitly (using assignment function call, or as a result of reading from a stream) or not. The stream's <span class="nctnt ncbi-func">SetVerifyData()</span> method defines a stream behavior in case it comes across an uninitialized data member.

There are three kinds of object data members:

-   optional ones,

-   mandatory with a default value,

-   mandatory with no default value.

Optional members and mandatory ones with no default have "no value" initially. As such, they are "ungetatable"; that is, <span class="nctnt ncbi-func">GetXXX()</span> throws an exception (this is also configurable though). Mandatory members with a default are always getable, but not always set. It is possible to assign a default value to a mandatory member with a default value. In this case it becomes set, and as such will be written into an output stream.

The discussion above refers only to primitive data members, such as strings, or integers. The behavior of containers is somewhat different. All containers are pre-created on the parent object construction, so for container data members <span class="nctnt ncbi-func">CanGetXXX()</span> always returns TRUE. This can be justified by the fact that containers have a sort of "natural default value" - empty. Also, <span class="nctnt ncbi-func">IsSetXXX()</span> will return TRUE if the container is either mandatory, or has been read (even if empty) from the input stream, or <span class="nctnt ncbi-func">SetXXX()</span> was called for it.

The following additional topics are discussed in this section:

-   [Initialization Verification in CSerialObject Classes](#initialization-verification-in-cserialobject-classes)

-   [Initialization Verification in Object Streams](#initialization-verification-in-object-streams)

#### Initialization Verification in <span class="nctnt ncbi-class">CSerialObject</span> Classes

<span class="nctnt ncbi-class">CSerialObject</span> defines two functions to manage how uninitialized data members would be treated:

        static void SetVerifyDataThread(ESerialVerifyData verify);
        static void SetVerifyDataGlobal(ESerialVerifyData verify);

The <span class="nctnt ncbi-func">SetVerifyDataThread()</span> defines the behavior of <span class="nctnt ncbi-func">GetXXX()</span> for the current thread, while the <span class="nctnt ncbi-func">SetVerifyDataGlobal()</span> for the current process. Please note, that disabling <span class="nctnt ncbi-class">CUnassignedMember</span> exceptions in <span class="nctnt ncbi-func">GetXXX()</span> function is potentially dangerous because it could silently return garbage.

The behavior of initialization verification has been designed to allow for maximum flexibility. It is possible to define it using environment variables, and then override it in a program, and vice versa. It is also possible to force a specific behavior, no matter what the program sets, or could set later on. The <span class="nctnt ncbi-type">ESerialVerifyData</span> enumerator could have the following values:

-   <span class="nctnt ncbi-monospace">eSerialVerifyData\_Default</span>

-   <span class="nctnt ncbi-monospace">eSerialVerifyData\_No</span>

-   <span class="nctnt ncbi-monospace">eSerialVerifyData\_Never</span>

-   <span class="nctnt ncbi-monospace">eSerialVerifyData\_Yes</span>

-   <span class="nctnt ncbi-monospace">eSerialVerifyData\_Always</span>

Setting <span class="nctnt ncbi-type">eSerialVerifyData\_Never</span> or <span class="nctnt ncbi-type">eSerialVerifyData\_Always</span> results in a "forced" behavior: setting <span class="nctnt ncbi-type">eSerialVerifyData\_Never</span> prohibits later attempts to enable verification; setting <span class="nctnt ncbi-type">eSerialVerifyData\_Always</span> prohibits attempts to disable it. The default behavior could be defined from the outside, using the <span class="nctnt ncbi-var">SET\_VERIFY\_DATA\_GET</span> environment variable:

        SET_VERIFY_DATA_GET ::= ( 'NO' \| 'NEVER' \| 'YES' \| 'ALWAYS' )

Alternatively, the default behavior can also be set from a program code using <span class="nctnt ncbi-func">CSerialObject::SetVerifyDataXXX()</span> functions.

Setting the environment variable to "Never/Always" overrides any attempt to change the verification behavior in the program. Setting "Never/Always" for the process overrides attempts to change it for a thread. "Yes/No" setting is less restrictive: the environment variable, if present, provides the default, which could then be overridden in a program, or thread. Here thread settings supersede the process ones.

#### Initialization Verification in Object Streams

Data member verification in object streams is a bit more complex.

First, it is possible to set the verification behavior on three different levels:

-   for a specific stream (<span class="nctnt ncbi-func">SetVerifyData()</span>),

-   for all streams created by a current thread (<span class="nctnt ncbi-func">SetVerifyDataThread()</span>),

-   for all stream created by the current process (<span class="nctnt ncbi-func">SetVerifyDataGlobal()</span>).

Second, there are more options in defining what to do in case of an uninitialized data member:

-   throw an exception;

-   skip it on writing (write nothing), and leave uninitialized (as is) on reading;

-   write some default value on writing, and assign it on reading (even though there is no default).

To accommodate these situations, the <span class="nctnt ncbi-type">ESerialVerifyData</span> enumerator has two additional values:

-   <span class="nctnt ncbi-monospace">eSerialVerifyData\_DefValue</span>

-   <span class="nctnt ncbi-monospace">eSerialVerifyData\_DefValueAlways</span>

In this case, on reading a missing data member, stream initializes it with a "default" (usually 0); on writing the unset data member, it writes it "as is". For comparison: in the "No/Never" case on reading a missing member stream could initialize it with a "garbage", while on writing it writes nothing. The latter case produces semantically incorrect output, but preserves information of what has been set, and what is not set.

The default behavior could be set similarly to CSerialObject. The environment variables are as follows:

        SET_VERIFY_DATA_READ  ::= ( 'NO' \| 'NEVER' \| 'YES' \| 'ALWAYS' \|
     'DEFVALUE' \| 'DEFVALUE_ALWAYS' )
        SET_VERIFY_DATA_WRITE ::= ( 'NO' \| 'NEVER' \| 'YES' \| 'ALWAYS' \|
     'DEFVALUE' \| 'DEFVALUE_ALWAYS' )

### Simplified Serialization Interface

The reading and writing of serial object requires creation of special object streams which encode and decode data. While such streams provide with a greater flexibility in setting the formatting parameters, in some cases it is not needed - the default behavior is quite enough. NCBI C++ toolkit library makes it possible to use the standard I/O streams in this case, thus hiding the creation of object streams. So, the serialization would look like this:

    cout << MSerial_AsnText << obj;

The only information that is always needed is the output format. It is defined by the following stream manipulators:

-   <span class="nctnt ncbi-func">MSerial\_AsnText</span>

-   <span class="nctnt ncbi-func">MSerial\_AsnBinary</span>

-   <span class="nctnt ncbi-func">MSerial\_Json</span>

-   <span class="nctnt ncbi-func">MSerial\_Xml</span>

Few additional manipulators define the handling of un-initialized object data members:

-   <span class="nctnt ncbi-func">MSerial\_VerifyDefault</span>

-   <span class="nctnt ncbi-func">MSerial\_VerifyNo</span>

-   <span class="nctnt ncbi-func">MSerial\_VerifyYes</span>

-   <span class="nctnt ncbi-func">MSerial\_VerifyDefValue</span>

### Finding in input stream objects of a specific type

When processing serialized data, it is pretty often that one has to find all objects of a specific type, with this type not being a root one. To make it easier, serial library defines a helper template function <span class="nctnt ncbi-func">Serial\_FilterObjects</span>. The idea is to be able to define a special hook class with a single virtual function <span class="nctnt ncbi-func">Process</span> with a single parameter: object of the requested type. Input stream is being scanned then, and, when an object of the requested type is encountered, the user-supplied function is being called.

For example, suppose an input stream contains Bioseq objects, and you need to find and process all Seq-inst objects in it. First, you need to define a class that will process them:

    Class CProcessSeqinstHook : public
    CSerial_FilterObjectsHook<CSeq_inst>
    {
    public:
        virtual void Process(const CSeq_inst& obj);
    };

Second, you just call filtering function specifying the root object type:

    Serial_FilterObjects<CBioseq>(input_stream, new
    CProcessSeqinstHook());

Another variant of this function – <span class="nctnt ncbi-func">Serial\_FilterStdObjects</span> – finds objects of standard type, not derived from <span class="nctnt ncbi-class">CSerialObject</span> – strings, for example. The usage is similar. First, define a hook class that will process data:

    class CProcessStringHook : public CSerial_FilterObjectsHook<string>
    {
    public:
        virtual void Process(const string& obj);
    };

Then, call the filtering function:

    Serial_FilterStdObjects<CBioseq>(input_stream, new CProcessStringHook());

An even more sophisticated, yet easier to use mechanism relies on multi-threading. It puts data reading into a separate thread and hides synchronization issues from client application. There are two template classes, which make it possible: <span class="nctnt ncbi-class">CIStreamObjectIterator</span> and <span class="nctnt ncbi-class">CIStreamStdIterator</span>. The former finds objects of <span class="nctnt ncbi-class">CSerialObject</span> type:

    CIStreamObjectIterator<CBioseq,CSeq_inst> i(input_stream);
    for ( ; i.IsValid(); ++i) {
        const CSeq_inst& obj = *i;
        ...
    }

The latter – objects of standard type:

    CIStreamStdIterator<CBioseq,string> i(input_stream);
    for ( ; i.IsValid(); ++i) {
        const string& obj = *i;
        ...
    }

The NCBI C++ Toolkit Iterators
------------------------------

The following topics are discussed in this section:

-   [STL generic iterators](#stl-generic-iterators)

-   [CTypeIterator (\*) and CTypeConstIterator (\*)](#ctypeiterator-*-and-ctypeconstiterator-*)

-   [Class hierarchies, embedded objects, and the NCBI C++ type iterators](#class-hierarchies-embedded-objects-and-the-ncbi-c++-type-iterators)

-   [CObjectIterator (\*) and CObjectConstIterator (\*)](#cobjectiterator-*-and-cobjectconstiterator-*)

-   [CStdTypeIterator (\*) and CStdTypeConstIterator (\*)](#cstdtypeiterator-*-and-cstdtypeconstiterator-*)

-   [CTypesIterator (\*)](#ctypesiterator-*)

-   [Context filtering in type iterators](#context-filtering-in-type-iterators)

-   [Additional Information](#additional-information)

### <span class="nctnt ncbi-lib">STL</span> generic iterators

Iterators are an important cornerstone in the generic programming paradigm - they serve as intermediaries between generic containers and generic algorithms. Different containers have different access properties, and the interface to a generic algorithm must account for this.

The <span class="nctnt ncbi-class">vector</span> class allows <span class="nctnt ncbi-monospace">input, output, bidirectional,</span> and <span class="nctnt ncbi-monospace">random access</span> iterators. In contrast, the <span class="nctnt ncbi-class">list</span> container class does **not** allow random access to its elements. This is depicted graphically by one less strand in the ribbon connector. In addition to the iterators, the generic algorithms may require function objects such as <span class="nctnt ncbi-code">less\<T\></span> to support the template implementations.

The STL standard iterators are designed to iterate through any STL container of homogeneous elements, e.g., <span class="nctnt ncbi-monospace">vectors, lists, deques, stacks, maps, multimaps, sets, multisets, </span>etc. A prerequisite however, is that the container must have <span class="nctnt ncbi-func">begin()</span> and <span class="nctnt ncbi-func">end()</span> functions defined on it as start and end points for the iteration.

But while these standard iterators are powerful tools for generic programming, they are of no help in iterating over the elements of <span class="nctnt ncbi-monospace">aggregate</span> objects - e.g., over the heterogeneous data members of a class object. As this is an essential operation in processing serialized data structures, the NCBI C++ Toolkit provides additional types of iterators for just this purpose. In the section on [Runtime object type information](#runtime-object-type-information), we described the [CMemberIterator](#cmemberiterator) and [CVariantIterator](#cvariantiterator) classes, which provide access to the instance and type information for **all** of the sequence members and choice variants of a sequence or choice object. In some cases however, we may wish to visit only those data members which are of a certain type, and do not require any type information. The iterators described in this section are of this type.

### <span class="nctnt ncbi-class">CTypeIterator</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCTypeIterator.html)) and <span class="nctnt ncbi-class">CTypeConstIterator</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCTypeConstIterator.html))

The <span class="nctnt ncbi-class">CTypeIterator</span> and <span class="nctnt ncbi-class">CTypeConstIterator</span> can be used to traverse a structured object, stopping at all data members of a specified type. For example, it is very common to represent a linked list of objects by encoding a next field that embeds an object of the same type. One way to traverse the linked list then, would be to "iterate" over all objects of that type, beginning at the head of the list. For example, suppose you have a <span class="nctnt ncbi-class">CPerson</span>class defined as:

    class CPerson
    {
    public:
        CPerson(void);
        CPerson(const string& name, const string& address, CPerson* p);
        virtual ~CPerson(void);
        static const CTypeInfo* GetTypeInfo(void);
        string m_Name, m_Addr;
        CPerson *m_NextDoor;
    };

Given this definition, one might then define a <span class="nctnt ncbi-var">neighborhood</span> using a single <span class="nctnt ncbi-class">CPerson</span>. Assuming a function <span class="nctnt ncbi-func">FullerBrushMan(CPerson&)</span> must now be applied to each person in the neighborhood, this could be implemented using a <span class="nctnt ncbi-class">CTypeIterator</span> as follows:

    CPerson neighborhood("Moe", "123 Main St",
                         new CPerson("Larry", "127 Main St",
                         new CPerson("Curly", "131 Main St", 0)));
    for (CTypeIterator<CPerson> house(Begin(neighborhood)); house; ++house ) {
        FullerBrushMan(*house);
    }

In this example, the data members visited by the iterator are of the same type as the top-level aggregate object, since <span class="nctnt ncbi-var">neighbor</span> is an instance of <span class="nctnt ncbi-class">CPerson</span>. Thus, the first "member" visited is the top-level object itself. This is not always the case however. The top-level object is only included in the iteration when it is an instance of the type specified in the template argument (<span class="nctnt ncbi-class">CPerson</span> in this case).

All of the NCBI C++ Toolkit type iterators are <span class="nctnt ncbi-monospace">recursive</span>. Thus, since <span class="nctnt ncbi-var">neighborhood</span> has <span class="nctnt ncbi-class">CPerson</span> data members, which in turn contain objects of type <span class="nctnt ncbi-class">CPerson</span>, all of the nested data members will also be visited by the above iterator. More generally, given a hierarchically structured object containing data elements of a given type nested several levels deep, the NCBI C++ Toolkit type iterators effectively generate a "flat" list of all these elements.

It is not difficult to imagine situations where recursive iterators such as the <span class="nctnt ncbi-class">CTypeIterator</span> could lead to infinite loops. An obvious example of this would be a doubly-linked list. For example, suppose <span class="nctnt ncbi-class">CPerson</span> had both <span class="nctnt ncbi-var">previous</span> and <span class="nctnt ncbi-var">next</span> data members, where <span class="nctnt ncbi-code">x-\>next-\>previous == x</span>. In this case, visiting <span class="nctnt ncbi-var">x</span> followed by <span class="nctnt ncbi-var">x-\>next</span> would lead back to <span class="nctnt ncbi-var">x</span> with no terminating condition. To address this issue, the <span class="nctnt ncbi-func">Begin()</span> function accepts an optional second argument, [eDetectLoops](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EDetectLoops). <span class="nctnt ncbi-var">eDetectLoops</span> is an <span class="nctnt ncbi-code">enum</span> value which, if included, specifies that the iterator should detect and avoid infinite loops. The resulting iterator will be somewhat slower but can be safely used on objects whose references might create loops.

Let's compare the syntax of this new iterator class to the traditional iterators:

    ContainerType<T> x;

    // a traditional approach:
    for (ContainerType<T>::IteratorType it = x.begin(); it != x.end(); ++it)

    // it's generally better to use ITERATOR:
    ITERATE(ContainerType<T> it, x)

    // or you can use CTypeIterator:
    for (CTypeIterator<T> it(Begin(ObjectName)); it; ++it)

The traditional for loop iteration begins by pointing to the first item in the container <span class="nctnt ncbi-func">x.begin()</span>, and with each iteration, visits subsequent items until the end of the container <span class="nctnt ncbi-func">x.end()</span> is reached.

The <span class="nctnt ncbi-macro">ITERATE</span> macro does essentially the same thing, but it saves <span class="nctnt ncbi-func">x.end()</span> instead of re-evaluating it every iteration.

Similarly, the <span class="nctnt ncbi-class">CTypeIterator</span> begins by pointing to the first data member of <span class="nctnt ncbi-var">ObjectName</span> that is of type <span class="nctnt ncbi-type">T</span>, and with each iteration, visits subsequent data members of type <span class="nctnt ncbi-type">T</span> until the end of the top-level object is reached.

A lot of code actually uses <span class="nctnt ncbi-code">= Begin(...)</span> instead of <span class="nctnt ncbi-code">(Begin(...))</span> to initialize iterators; although the alternate syntax is somewhat more readable and often works, some compilers can mis-handle it and give you link errors. As such, direct initialization as shown above generally works better. Also, note that this issue only applies to construction; you should (and must) continue to use <span class="nctnt ncbi-code">=</span> to reset existing iterators.

How are generic iterators such as these implemented? The [Begin()](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=Begin) expression returns an object containing a pointer to the input object <span class="nctnt ncbi-var">ObjectName</span>, as well as a pointer to a [CTypeInfo](#ctypeinfo) object containing <span class="nctnt ncbi-monospace">type information</span> about that object. On each iteration, the <span class="nctnt ncbi-code">++</span> operator examines the **current** type information to find the next data member which is of type <span class="nctnt ncbi-type">T</span>. The current object, its type information, and the state of iteration is pushed onto a local stack, and the iterator is then reset with a pointer to the next object found, and in turn, a pointer to its type information. Each data member of type <span class="nctnt ncbi-type">T</span> (or derived from type <span class="nctnt ncbi-type">T</span>) must be capable of providing its own type information as needed. This allows the iterator to recursively visit all data members of the specified type at all levels of nesting.

More specifically, each object included in the iteration, as well as the initial argument to <span class="nctnt ncbi-func">Begin()</span>, must have a statically implemented [GetTypeInfo()](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=GetTypeInfo) class member function to provide the needed type information. For example, all of the serializable objects generated by [datatool](ch_app.html#ch_app.datatool) in the <span class="nctnt ncbi-path">src/objects</span> subtrees have <span class="nctnt ncbi-func">GetTypeInfo()</span> member functions. In order to apply type iterators to user-defined classes (as in the above example), these classes must also make their type information explicit. A set of macros described in the section on [User-defined Type Information](#user-defined-type-information) are provided to simplify the implementation of the <span class="nctnt ncbi-func">GetTypeInfo()</span> methods for user-defined classes. The example included at the end of this section (see [Additional Information](#additional-information)) uses several of the C++ Toolkit type iterators and demonstrates how to apply some of these macros.

The <span class="nctnt ncbi-class">CTypeConstIterator</span> parallels the <span class="nctnt ncbi-class">CTypeIterator</span>, and is intended for use with <span class="nctnt ncbi-code">const</span> objects (i.e. when you want to prohibit modifications to the objects you are iterating over). For <span class="nctnt ncbi-code">const</span> iterators, the <span class="nctnt ncbi-func">ConstBegin()</span> function should be used in place of <span class="nctnt ncbi-func">Begin()</span>.

### Class hierarchies, embedded objects, and the NCBI C++ type iterators

As emphasized above, all of the objects visited by an iterator must have the <span class="nctnt ncbi-func">GetTypeInfo()</span> member function defined in order for the iterators to work properly. For an iterator that visits objects of type <span class="nctnt ncbi-type">T</span>, the type information provided by <span class="nctnt ncbi-func">GetTypeInfo()</span> is used to identify:

-   data members of type <span class="nctnt ncbi-type">T</span>

-   data members containing objects of type <span class="nctnt ncbi-type">T</span>

-   data members derived from type <span class="nctnt ncbi-type">T</span>

-   data members containing objects derived from type <span class="nctnt ncbi-type">T</span>

Explicit encoding of the class hierarchy via the <span class="nctnt ncbi-func">GetTypeInfo()</span> methods allows the user to deploy a type iterator over a single specified type which may in practice include a set of types via inheritance. The section [Additional Information](#additional-information) includes a simple example of this feature. The preprocessor macros used in this example which support the encoding of hierarchical class relations are described in the [User-defined Type Information](#user-defined-type-information) section. A further generalization of this idea is implemented by the [CTypesIterator](#ctypesiterator) described later.

### <span class="nctnt ncbi-class">CObjectIterator</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial/iterator.hpp)) and <span class="nctnt ncbi-class">CObjectConstIterator</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial/iterator.hpp))

Because the <span class="nctnt ncbi-class">CObject</span> class is so central to the Toolkit, a special iterator is also defined, which can automatically distinguish <span class="nctnt ncbi-class">CObject</span>s from other class types. The syntax of a <span class="nctnt ncbi-class">CObjectIterator</span> is:

    for (CObjectIterator i(Begin(ObjectName)); i; ++i)

Note that there is no need to specify the object type to iterate over, as the type <span class="nctnt ncbi-class">CObject</span> is built into the iterator itself. This iterator will recursively visit all <span class="nctnt ncbi-class">CObject</span>s contained or referenced in <span class="nctnt ncbi-var">ObjectName</span>. The <span class="nctnt ncbi-class">CObjectConstIterator</span> is identical to the <span class="nctnt ncbi-class">CObjectIterator</span> but is designed to operate on <span class="nctnt ncbi-code">const</span> elements and uses the <span class="nctnt ncbi-func">ConstBegin()</span> function.

User-defined classes that are derived from <span class="nctnt ncbi-class">CObject</span> can also be iterated over (assuming their <span class="nctnt ncbi-func">GetTypeInfo()</span> methods have been implemented). In general however, care should be used in applying this type of iterator, as not all of the NCBI C++ Toolkit classes derived from <span class="nctnt ncbi-func">CObject</span> have implementations of the <span class="nctnt ncbi-func">GetTypeInfo()</span> method. **All** of the generated serializable objects in <span class="nctnt ncbi-path">include/objects</span> **do** have a defined <span class="nctnt ncbi-func">GetTypeInfo()</span> member function however, and thus can be iterated over using either a <span class="nctnt ncbi-class">CObjectIterator</span> or a <span class="nctnt ncbi-class">CTypeIterator</span> with an appropriate template argument.

### <span class="nctnt ncbi-class">CStdTypeIterator</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCStdTypeIterator.html)) and <span class="nctnt ncbi-class">CStdTypeConstIterator</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCStdTypeConstIterator.html))

All of the type iterators described thus far require that each object visited must provide its own type information. Hence, none of these can be applied to standard types such as <span class="nctnt ncbi-type">int, float, double</span> or the STL type <span class="nctnt ncbi-type">string</span>. The <span class="nctnt ncbi-class">CStdTypeIterator</span> and <span class="nctnt ncbi-class">CStdTypeConstIterator</span> classes selectively iterate over data members of a specified type. But for these iterators, the type **must** be a simple C type (<span class="nctnt ncbi-type">int, double, char\*, etc.</span>) or an STL type <span class="nctnt ncbi-type">string</span>. For example, to iterate over all the <span class="nctnt ncbi-type">string</span> data members in a <span class="nctnt ncbi-class">CPerson</span> object, we could use:

    for (CStdTypeIterator<string> i(Begin(neighborhood)); i; ++i) {
        cout << *i << ' ';
    }

The <span class="nctnt ncbi-class">CStdTypeConstIterator</span> is identical to the <span class="nctnt ncbi-class">CStdTypeIterator</span> but is designed to operate on <span class="nctnt ncbi-code">const</span> elements and requires the <span class="nctnt ncbi-func">ConstBegin()</span> function.

For examples using <span class="nctnt ncbi-class">CTypeIterator</span> and <span class="nctnt ncbi-class">CStdTypeIterator</span>, see [Code Sample 2 (ctypeiter.cpp)](#code-sample-2-ctypeitercpp) and [Code Sample 3 (ctypeiter.hpp)](#code-sample-3-ctypeiterhpp).

#### Code Sample 2. ctypeiter.cpp

    // File name: ctypeiter.cpp
    // Description: Demonstrate using a CTypeIterator
    // Notes: build with xncbi and xser libraries

    #include "ctypeiter.hpp"
    #include <serial/serial.hpp>
    #include <serial/objistr.hpp>
    #include <serial/objostr.hpp>
    #include <serial/iterator.hpp>
    #include <serial/serialimpl.hpp>

    //  type information for class CPerson
    BEGIN_CLASS_INFO(CPerson){
        ADD_STD_MEMBER(m_Name);
        ADD_STD_MEMBER(m_Addr);
        ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)))->SetOptional();
    }END_CLASS_INFO

    //  type information for class CDistrict
    BEGIN_CLASS_INFO(CDistrict){
        ADD_STD_MEMBER(m_Number);
        ADD_MEMBER(m_Blocks, STL_list, (CLASS, (CPerson)));
    }END_CLASS_INFO

    // main and other functions
    USING_NCBI_SCOPE;

    static void FullerBrushMan (const CPerson& p) {
        cout << "knock-knock! is " << p.m_Name << " home?" << endl;
    }

    int main(int argc, char** argv)
    {
        // Instantiate a few CPerson objects
        CPerson neighborhood("Moe", "1 Main St",
                             new CPerson("Larry", "2 Main St",
                                         new CPerson("Curly", "3 Main St", 0)));
        CPerson another("Harpo", "2 River Rd",
                        new CPerson("Chico", "4 River Rd",
                                    new CPerson("Groucho", "6 River Rd", 0)));

        // Create a CDistrict and install some CPerson objects
        CDistrict district1(1);
        district1.AddBlock(neighborhood);
        district1.AddBlock(another);
        // Send the FullerBrushMan to all CPersons in district1
        for (CTypeConstIterator<CPerson> house = ConstBegin(district1);
             house; ++house ) {
            FullerBrushMan(*house);
        }
        // Iterate over all strings for the CPersons in district1
        list<CPerson> blocks(district1.GetBlocks());
        ITERATE(list<CPerson>, b, blocks) {
            for (CStdTypeIterator<string> it(Begin(*b));  it;  ++it) {
                cout << *it << ' ';
            }
            cout << endl;
        }
        return 0;
    }

#### Code Sample 3. ctypeiter.hpp

    // File name: ctypeiter.hpp

    #ifndef CTYPEITER_HPP
    #define CTYPEITER_HPP

    #include <corelib/ncbistd.hpp>
    #include <corelib/ncbiobj.hpp>
    #include <serial/typeinfo.hpp>
    #include <string>
    #include <list>

    USING_NCBI_SCOPE;

    class CPerson
    {
    public:
        CPerson(void)
            : m_Name(0), m_Addr(0), m_NextDoor(0) {}
        CPerson(string n, string s, CPerson* p)
            : m_Name(n), m_Addr(s), m_NextDoor(p) {}
        virtual ~CPerson(void) {}
        static const CTypeInfo* GetTypeInfo(void);
    private:
        string m_Name, m_Addr;
        CPerson *m_NextDoor;
    };

    class CDistrict
    {
    public:
        CDistrict(void)
            : m_Number(0) {}
        CDistrict(int n) : m_Number(n) {}
        virtual ~CDistrict(void) {}
        static const CTypeInfo* GetTypeInfo(void);
        int m_Number;
        void AddBlock (const CPerson& p) { m_Blocks.push_back(p); }
        list<CPerson>& GetBlocks() { return m_Blocks; }
    private:
        list<CPerson> m_Blocks;
    };
    #endif /* CTYPEITER_HPP */

### <span class="nctnt ncbi-class">CTypesIterator</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CTypesIterator))

Sometimes it is necessary to iterate over a set of types contained inside an object. The <span class="nctnt ncbi-class">CTypesIterator</span>, as its name suggests, is designed for this purpose. For example, suppose you have loaded a gene sequence into memory as a <span class="nctnt ncbi-class">CBioseq</span> (named <span class="nctnt ncbi-var">seq</span>), and want to iterate over all of its references to genes and organisms. The following sequence of statements defines an iterator that will step through all of <span class="nctnt ncbi-var">seq</span>'s data members (recursively), stopping only at references to gene and organism citations:

    CTypesIterator i;
    CType<CGene_ref>::AddTo(i);    // define the types to stop at
    CType<COrg_ref>::AddTo(i);

    for (i = Begin(seq); i; ++i) {

        if (CType<CGene_ref>::Match(i)) {
            CGene_ref* geneRef = CType<CGene_ref>::Get(i);
            ...
        }
        else if (CType<COrg_ref>::Match(i) {
            COrg_ref* orgRef = CType<COrg_ref>::Get(i);
            ...
        }
    }

Here, [CType](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCType.html) is a helper template class that simplifies the syntax required to use the multiple types iterator:

-   <span class="nctnt ncbi-code">CType\<TypeName\>::AddTo(i)</span> specifies that iterator <span class="nctnt ncbi-var">i</span> should stop at type <span class="nctnt ncbi-type">TypeName</span>.

-   <span class="nctnt ncbi-code">CType\<TypeName\>::Match(i)</span> returns <span class="nctnt ncbi-monospace">true</span> if the specified type <span class="nctnt ncbi-type">TypeName</span> is the type currently pointed to by iterator <span class="nctnt ncbi-var">i</span>.

-   <span class="nctnt ncbi-code">CType\<TypeName\>::Get(i)</span> retrieves the object currently pointed to by iterator <span class="nctnt ncbi-var">i</span>**if** there is a type match to <span class="nctnt ncbi-type">TypeName</span>, and otherwise returns 0. In the event there is a type match, the retrieved object is type cast to <span class="nctnt ncbi-type">TypeName</span> before it is returned.

The <span class="nctnt ncbi-func">Begin()</span> expression is as described for the above <span class="nctnt ncbi-class">CTypeIterator</span> and <span class="nctnt ncbi-class">CTypeConstIterator</span> classes. The [CTypesConstIterator](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CTypesConstIterator) is the <span class="nctnt ncbi-code">const</span> implementation of this type of iterator, and requires the <span class="nctnt ncbi-func">ConstBegin()</span> function.

### Context Filtering In Type Iterators

In addition to traversing objects of a specific type one might want to specify the structural context in which such objects should appear. For example, you might want to iterate over <span class="nctnt ncbi-type">string</span> data members, but only those called <span class="nctnt ncbi-monospace">title</span>. This could be done using context filtering. Such a filter is a string with the format identical to the one used in [Stack Path Hooks](#stack-path-hooks) and is specified as an additional parameter of a type iterator. So, for example, the declaration of a string data member iterator with context filtering could look like this:

    CStdTypeIterator<string> i(Begin(my_obj), "*.title")

### Additional Information

The following example demonstrates how the class hierarchy determines which data members will be included in a type iterator. The example uses five simple classes:

-   Class <span class="nctnt ncbi-class">CA</span> contains a single <span class="nctnt ncbi-type">int</span> data member and is used as a target object type for the type iterators demonstrated.

-   class <span class="nctnt ncbi-class">CB</span> contains an <span class="nctnt ncbi-class">auto\_ptr</span> to a <span class="nctnt ncbi-class">CA</span> object.

-   Class <span class="nctnt ncbi-class">CC</span> is derived from <span class="nctnt ncbi-class">CA</span> and is used to demonstrate the usage of class hierarchy information.

-   Class <span class="nctnt ncbi-class">CD</span> contains an <span class="nctnt ncbi-class">auto\_ptr</span> to a <span class="nctnt ncbi-class">CC</span> object, and, since it is derived from <span class="nctnt ncbi-class">CObject</span>, can be used as the object pointed to by a [CRef](ch_core.html#ch_core.smart_ptrs).

-   Class <span class="nctnt ncbi-class">CX</span> contains both pointers-to and instances-of <span class="nctnt ncbi-class">CA, CB, CC</span>, and <span class="nctnt ncbi-class">CD</span> objects, and is used as the argument to <span class="nctnt ncbi-func">Begin()</span> for the demonstrated type iterators.

The preprocessor macros used in this example implement the <span class="nctnt ncbi-func">GetTypeInfo()</span> methods for the classes, and are described in the section on [User-defined type information](#user-defined-type-information).

    // Define a simple class to use as iterator's target objects
    class CA
    {
    public:
        CA() : m_Data(0) {};
        CA(int n) : m_Data(n) {};
        static const CTypeInfo* GetTypeInfo(void);
        int m_Data;
    };
    // Define a class containing an auto_ptr to the target class
    class CB
    {
    public:
        CB() : m_a(0) {};
        static const CTypeInfo* GetTypeInfo(void);
        auto_ptr<CA> m_a;
    };
    // define a subclass of the target class
    class CC : public CA
    {
    public:
        CC() : CA(0){};
        CC(int n) : CA(n){};
        static const CTypeInfo* GetTypeInfo(void);
    };

    // define a class derived from CObject to use in a CRef
    // this class also contains an auto_ptr to the target class
    class CD : public CObject
    {
    public:
        CD() : m_c(0) {};
        static const CTypeInfo* GetTypeInfo(void);
        auto_ptr<CC> m_c;
    };
    // This class will be the argument to the iterator. It contains 4
    // instances of CA - directly, through pointers, and via inheritance
    class CX
    {
    public:
        CX() : m_a(0), m_b(0), m_d(0) {};
        ~CX(){};
        static const CTypeInfo* GetTypeInfo(void);
        auto_ptr<CA> m_a; // auto_ptr to a CA
        CB *m_b;          // pointer to an object containing a CA
        CC  m_c;          // instance of a subclass of CA
        CRef<CD> m_d;     // CRef to an object containing an auto_ptr to CC
    };
    //////////  Implement the GetTypeInfo() methods /////////
    ////////// (see User-defined type information)  /////////
    BEGIN_CLASS_INFO(CA)
    {
        ADD_STD_MEMBER(m_Data);
        ADD_SUB_CLASS(CC);
    }
    END_CLASS_INFO


    BEGIN_CLASS_INFO(CB)
    {
        ADD_MEMBER(m_a, STL_auto_ptr, (CLASS, (CA)));
    }
    END_CLASS_INFO


    BEGIN_DERIVED_CLASS_INFO(CC, CA)
    {
    }
    END_DERIVED_CLASS_INFO


    BEGIN_CLASS_INFO(CD)
    {
        ADD_MEMBER(m_c, STL_auto_ptr, (CLASS, (CC)));
    }
    END_CLASS_INFO


    BEGIN_CLASS_INFO(CX)
    {
        ADD_MEMBER(m_a, STL_auto_ptr, (CLASS, (CA)));
        ADD_MEMBER(m_b, POINTER, (CLASS, (CB)));
        ADD_MEMBER(m_c, CLASS, (CC));
        ADD_MEMBER(m_d, STL_CRef, (CLASS, (CD)));
    }
    END_CLASS_INFO

    int main(int argc, char** argv)
    {
        CB b;
        CD d;

        b.m_a.reset(new CA(2));
        d.m_c.reset(new CC(4));
        CX x;

        x.m_a.reset(new CA(1));    // auto_ptr to CA
        x.m_b = &b;            // pointer to CB containing auto_ptr to CA
        x.m_c = *(new CC(3));      // instance of subclass of CA
        x.m_d = &d;            // CRef to CD containing auto_ptr to CC

        cout << "Iterating over CA objects in x" << endl << endl;

        for (CTypeIterator<CA> i(Begin(x)); i; ++i)
            cout << (*i).m_Data << endl;

        cout << "Iterating over CC objects in x" << endl << endl;

        for (CTypeIterator<CC> i(Begin(x)); i; ++i)
            cout << (*i).m_Data << endl;

        cout << "Iterating over CObjects in x" << endl << endl;
        for (CObjectIterator i(Begin(x)); i; ++i) {
            const CD *tmp = dynamic_cast<const CD*>(&*i);
            cout << tmp->m_c->m_Data << endl;
        }
        return 0;
    }

Figure 1 illustrates the paths traversed by <span class="nctnt ncbi-class">CTypeIterator\<CA\></span> and <span class="nctnt ncbi-class">CTypeIterator\<CC\></span>, where both iterators are initialized with <span class="nctnt ncbi-func">Begin(a)</span>. The data members visited by the iterator are indicated by enclosing boxes. See [Figure 1](#figure-1).

[![Figure 1. Traversal path of the CTypeIterator](/book-test/static/img/typeiter.gif)](/book-test/static/img/typeiter.gif "Click to see the full-resolution image")

Figure 1. Traversal path of the CTypeIterator

For additional examples of using the type iterators described in this section, see [ctypeiter.cpp](#ctypeitercpp).

Processing Serial Data
----------------------

Although this discussion focuses on ASN.1 and XML formatted data, the data structures and tools described here have been designed to (potentially) support any formalized serial data specification. Many of the tools and objects have open-ended abstract or template implementations that can be instantiated differently to fit various specifications.

The following topics are discussed in this section

-   [Accessing the object header files and serialization libraries](#accessing-the-object-header-files-and-serialization-libraries)

-   [Reading and writing serial data](#reading-and-writing-serial-data)

-   [Reading and writing binary JSON data](#reading-and-writing-binary-json-data)

-   [Determining Which Header Files to Include](#determining-which-header-files-to-include)

-   [Determining Which Libraries to Link To](#determining-which-libraries-to-link-to)

### Accessing the object header files and serialization libraries

Reading and writing serialized data is implemented by an integrated set of streams, filters, and object types. An application that reads encoded data files will require the object header files and libraries which define how these serial streams of data should be loaded into memory. This entails <span class="nctnt ncbi-code">\#include</span> statements in your source files, as well as the associated library specifications in your makefiles. The object header and implementation files are located in the [include/objects](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects) and [src/objects](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects) subtrees of the C++ tree, respectively. The header and implementation files for serialized streams and type information are in the [include/serial](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial) and [src/serial](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/serial) directories.

If you have checked out the <span class="nctnt ncbi-path">objects</span> directories, but not explicitly run the [datatool](ch_app.html#ch_app.datatool) code generator, then you will find that your <span class="nctnt ncbi-path">include/objects</span> subdirectories are (almost) empty, and the source subdirectories contain only makefiles and ASN.1 specifications. These makefiles and ASN.1 specifications can be used to build your own copies of the objects' header and implementation files, using <span class="nctnt ncbi-cmd">make all\_r</span> (if you configured using the <span class="nctnt ncbi-cmd">--with-objects</span> flag), or running datatool explicitly.

However, building your own local copies of these header and implementation files is neither necessary nor recommended, as it is simpler to use the pre-generated header files and prebuilt libraries. The pre-built header and implementation files can be found in <span class="nctnt ncbi-path">$NCBI/c++/include/objects/</span> and <span class="nctnt ncbi-path">$NCBI/c++/src/objects/</span>, respectively. Assuming your makefile defines an include path to <span class="nctnt ncbi-path">$NCBI/c++/include</span>, selected object header files such as [Date.hpp](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/general/Date.hpp), can be included as:

    #include <objects/general/Date.hpp>

This header file (along with its implementations in the accompanying <span class="nctnt ncbi-path">src</span> directory) was generated by [datatool](ch_app.html#ch_app.datatool) using the specifications from [src/objects/general/general.asn](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/general/general.asn). In order to use the classes defined in the <span class="nctnt ncbi-path">objects</span> directories, your source code should begin with the statements:

    USING_NCBI_SCOPE;
    using namespace objects;

All of the objects' header and implementation files are generated by <span class="nctnt ncbi-app">datatool</span>, as specified in the ASN.1 specification files. The resulting object definitions however, are not in any way dependent on ASN.1 format, as they simply specify the in-memory representation of the defined data types. Accordingly, the objects themselves can be used to read, interpret, and write any type of serialized data. Format specializations on the input stream are implemented via [CObjectIStream](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStream.html) objects, which extract the required tags and values from the input data according to the format specified. Similarly, Format specializations on an output stream are implemented via [CObjectOStream](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStream.html) objects.

### Reading and writing serial data

Let's consider a program [xml2asn.cpp](#xml2asncpp) that translates an XML data file containing an object of type [Biostruc](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mmdb1/mmdb1.asn), to ASN.1 text and binary formats. In <span class="nctnt ncbi-func">main()</span>, we begin by initializing the diagnostic stream to write errors to a local file called <span class="nctnt ncbi-path">xml2asn.log</span>. (Exception handling, program tracing, and error logging are described in the [Diagnostic Streams](ch_core.html#ch_core.diag) section).

An instance of the <span class="nctnt ncbi-class">CTestAsn</span> class is then created, and its member function <span class="nctnt ncbi-func">AppMain()</span> is invoked. This function in turn calls <span class="nctnt ncbi-func">CTestAsn::Run()</span>. The first three lines of code there define the XML input and ASN.1 output streams, using [auto\_ptr](ch_core.html#ch_core.smart_ptrs), to ensure automatic destruction of these objects.

Each stream is associated with data serialization mechanisms appropriate to the [ESerialDataFormat](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ESerialDataFormat) provided to the constructor:

    enum ESerialDataFormat {
        eSerial_None      = 0,
        eSerial_AsnText   = 1,   /// ASN.1 text
        eSerial_AsnBinary = 2,   /// ASN.1 binary
        eSerial_Xml       = 3,   /// XML
        eSerial_Json      = 4    /// JSON
    };

<span class="nctnt ncbi-class">CObjectIStream</span> and <span class="nctnt ncbi-class">CObjectOStream</span> are base classes which provide generic interfaces between the specific type information of a serializable object and an I/O stream. The object stream classes that will actually be instantiated by this application, [CObjectIStreamXml](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStreamXml.html), [CObjectOStreamAsn](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStreamAsn.html), and [CObjectOStreamAsnBinary](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectOStreamAsnBinary.html), are descendants of these base classes.

Finally, a variable for the object type that will be generated from the input stream (in this case a [CBiostruc](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc.html)) is defined, and the <span class="nctnt ncbi-class">CObject[I/O]Stream</span> operators "\<\<" and "\>\>" are used to read and write the serialized data to and from the object. (Note that it is **not** possible to simply "pass the data through", from the input stream to the output stream, using a construct like: <span class="nctnt ncbi-code">\*inObject \>\> \*outObject</span>). The <span class="nctnt ncbi-class">CObject[I/O]Stream</span>s know nothing about the structure of the specific object - they have knowledge only of the serialization format (text ASN, binary ASN, XML, etc.). In contrast, the [CBiostruc](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc.html) knows nothing about I/O and serialization formats, but it contains explicit type information about itself. Thus, the <span class="nctnt ncbi-class">CObject[I/O]Stream</span>s can apply their specialized serialization methods to the data members of <span class="nctnt ncbi-class">CBiostruc</span> using the [type information](#type-information) associated with that object's class.

### Reading and writing binary JSON data

JSON is a purely text format - that is, all data values are string representations. Therefore, binary data cannot be serialized or deserialized as JSON without specifying an encoding. Furthermore, the encoding choice is not automatically stored with the encoded data, so the (de)serialization process must explicitly select an encoding.

The following code shows how to read binary JSON data:

    // Create JSON data with a Base64 encoded binary field.
    char jsonb[] = "{ \"Seq_data\": { \"ncbi2na\": \"ASNFZ4mrze8=\" } }";
    CNcbiIstrstream iss(jsonb);

    // Read the JSON data into a Seq-data object, using Base64 encoding.
    CObjectIStreamJson ijson;
    ijson.Open(iss);
    CSeq_data mySeq_data;
    ijson.SetBinaryDataFormat(CObjectIStreamJson::eString_Base64);
    ijson >> mySeq_data;

The following code shows how to write binary JSON data:

    // Use ASN.1 data to populate a Seq-data object.
    char asn[] = "Seq-data ::= ncbi2na '0123456789ABCDEF'H";
    CNcbiIstrstream iss(asn);
    auto_ptr<CObjectIStream> in(CObjectIStream::Open(eSerial_AsnText, iss));
    CSeq_data mySeq_data;
    *in >> mySeq_data;

    // Write the Seq-data object in JSON format with Base64 binary encoding.
    CObjectOStreamJson ojson(cout, false);
    ojson.SetBinaryDataFormat(CObjectOStreamJson::eString_Base64);
    ojson << mySeq_data;

### Determining Which Header Files to Include

As always, we include the <span class="nctnt ncbi-path">corelib</span> header files, <span class="nctnt ncbi-path">ncbistd.hpp</span> and <span class="nctnt ncbi-path">ncbiapp.hpp</span>. In addition, the <span class="nctnt ncbi-path">serial</span> header files that define the generic <span class="nctnt ncbi-class">CObject[IO]Stream</span> objects are included, along with <span class="nctnt ncbi-path">serial.hpp</span>, which defines generalized serialization mechanisms including the insertion (<span class="nctnt ncbi-code">\<\<</span>) and extraction (<span class="nctnt ncbi-code">\>\></span>) operators. Finally, we need to include the header file for the object type we will be using.

There are two source browsers that can be used to locate the appropriate header file for a particular object type. Object class names in the NCBI C++ Toolkit begin with the letter "C". Using the [class hierarchy browser](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/hierarchy.html), we find <span class="nctnt ncbi-class">CBiostruc</span>, derived from <span class="nctnt ncbi-class">CBiostruc\_Base</span>, which is in turn derived from <span class="nctnt ncbi-class">CObject</span>. Following the <span class="nctnt ncbi-monospace">CBiostruc</span> link, we can then use the <span class="nctnt ncbi-monospace">locate</span> button to move to the LXR source code navigator, and there, find the name of the header file. In this case, we find [CBiostruc.hpp](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb1/Biostruc.hpp) is located in <span class="nctnt ncbi-path">include/objects/mmdb1</span>. Alternatively, if we know the name of the C++ class, the source code navigator's [identifier search](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident) tool can be used directly. In summary, the following <span class="nctnt ncbi-code">\#include</span> statements appear at the top of [xml2asn.cpp](#xml2asncpp):

    #include <corelib/ncbiapp.hpp>
    #include <serial/serial.hpp>
    #include <serial/objistr.hpp>
    #include <serial/objostr.hpp>
    #include <objects/mmdb1/Biostruc.hpp>

### Determining Which Libraries to Link To

Determining which libraries must be linked to requires a bit more work and may involve some trial and error. The list of available libraries currently includes:

<span class="nctnt ncbi-var">access biblio cdd featdef general medlars medline mmdb1 mmdb2 mmdb3 ncbimime objprt proj pub pubmed seq seqalign seqblock seqcode seqfeat seqloc seqres seqset submit xcgi xconnect xfcgi xhtml xncbi xser</span>

It should be clear that we will need to link to the core library, <span class="nctnt ncbi-path">xncbi</span>, as well as to the serial library, <span class="nctnt ncbi-path">xser</span>. In addition, we will need to link to whatever object libraries are entailed by using a [CBiostruc](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc.html) object. Minimally, one would expect to link to the <span class="nctnt ncbi-path">mmdb</span> libraries. This in itself is insufficient however, as the <span class="nctnt ncbi-class">CBiostruc</span> class embeds other types of objects, including PubMed citations, features, and sequences, which in turn embed additional objects such as [Date](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDate.html). The makefile for <span class="nctnt ncbi-path">xml2asn.cpp</span>, <span class="nctnt ncbi-path">Makefile.xml2asn.app</span> lists the libraries required for linking in the make variable <span class="nctnt ncbi-var">LIB</span>.

    #########################################################################
    # This file was originally generated from by shell script "new_project.sh"
    #########################################################################
    APP = xml2asn
    OBJ = xml2asn
    LIB = mmdb1 mmdb2 mmdb3 seqloc seqfeat pub medline biblio general xser xncbi
    LIBS = $(NCBI_C_LIBPATH) -lncbi $(ORIG_LIBS)

See also the example program, [asn2asn.cpp](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/asn2asn/asn2asn.cpp) which demonstrates more generalized translation of <span class="nctnt ncbi-type">Seq-entry</span> and <span class="nctnt ncbi-type">Bioseq-set</span> (defined in [seqset.asn](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqset/seqset.asn)).

<span class="nctnt highlight">Note:</span> Two online tools are available to help determine which libraries to link with. See the [FAQ](ch_faq.html#ch_faq.faq.CannotFindObjectSymbol) for details.

User-defined type information
-----------------------------

The following topics are discussed in this section:

-   [Introduction](#introduction)

-   [Installing a GetTypeInfo() function: the BEGIN\_/END\_macros](#installing-a-gettypeinfo-function-the-beginendmacros)

-   [Specifying internal structure and class inheritance: the ADD\_ macros](#specifying-internal-structure-and-class-inheritance-the-add-macros)

### Introduction

Object type information, as it is used in the NCBI C++ Toolkit, is defined in the section on [Runtime Object Type Information](#runtime-object-type-information). As described there, all of the classes and constructs defined in the serial <span class="nctnt ncbi-path">include</span> and <span class="nctnt ncbi-path">src</span> directories have a static implementation of a <span class="nctnt ncbi-func">GetTypeInfo()</span> function that yields a [CTypeInfo](#ctypeinfo) for the object of interest. In this section, we describe how type information can also be generated and accessed for user-defined types. We begin with a review of some of the basic notions introduced in the previous discussion.

The type information for a class is stored outside any instances of that class, in a statically created [CTypeInfo](#ctypeinfo) object. A class's type information includes the class layout, inheritance relations, external alias, and various other attributes that are independent of specific instances. In addition, the type information object provides an interface to the class's data members.

Limited type information is also available for primitive data types, enumerations, containers, and pointers. The type information for a primitive type specifies that it is an <span class="nctnt ncbi-type">int, float,</span> or <span class="nctnt ncbi-type">char</span>, etc., and whether or not that element is signed. Enumerations are a special kind of primitive type, whose type information specifies its enumeration values and named elements. Type information for containers can specify both the type of container and the type of elements. The type information for a pointer provides convenient methods of access to the type information for the type pointed to.

For all types, the type information is encoded in a static <span class="nctnt ncbi-class">CTypeInfo</span> object, which is then accessed by all instances of a given type using a [GetTypeInfo()](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=GetTypeInfo) function. For class types, this function is implemented as a static method for the class. For non class types, <span class="nctnt ncbi-func">GetTypeInfoXxx()</span> is implemented as a static global function, where *Xxx* is a unique suffix generated from the type's name. With the first invocation of <span class="nctnt ncbi-func">GetTypeInfo()</span> for a given type, the static <span class="nctnt ncbi-class">CTypeInfo</span> object is created, which then persists (local to the function <span class="nctnt ncbi-func">GetTypeInfo()</span>) throughout execution. Subsequent calls to <span class="nctnt ncbi-func">GetTypeInfo()</span> simply return a pointer to this statically created local object.

In order to make type information about <span class="nctnt ncbi-monospace">user-defined</span> classes accessible to your application, the user-defined classes must also implement a static <span class="nctnt ncbi-func">GetTypeInfo()</span> method. A set of preprocessor [macros](#macros) is available, which greatly simplifies this effort. A pre-requisite to using these macros however, is that the class definition must include the following line:

    DECLARE_INTERNAL_TYPE_INFO();

This pre-processor macro will generate the following in-line statement in the class definition:

    static const NCBI_NS_NCBI::CTypeInfo* GetTypeInfo(void);

As with class objects, there must be some means of declaring the type information function for an enumeration prior to using the macros which implement that function. Given an enumeration named <span class="nctnt ncbi-type">EMyEnum</span>, <span class="nctnt ncbi-code">DECLARE\_ENUM\_INFO(EMyEnum)</span> will generate the following declaration:

    const CEnumeratedTypeValues* GetTypeInfo_enum_EMyEnum(void);

The <span class="nctnt ncbi-macro">DECLARE\_ENUM\_INFO()</span> macro should appear in the header file where the enumeration is defined, immediately following the definition. The <span class="nctnt ncbi-macro">DECLARE\_INTERNAL\_ENUM\_INFO</span> macro is intended for usage with internal class definitions, as in:

    class ClassWithEnum {
        enum EMyEnum {
            ...
        };

        DECLARE_INTERNAL_ENUM_INFO(EMyEnum);
        ...
    };

The C++ Toolkit also allows one to provide type information for legacy C style <span class="nctnt ncbi-code">struct</span> and <span class="nctnt ncbi-monospace">choice</span> elements defined in the C Toolkit. The mechanisms used to implement this are mentioned but not described in detail here, as it is not likely that newly-defined types will be in these categories.

### Installing a GetTypeInfo() function: the BEGIN\_/END\_macros

Several pre-processor macros are available for the installation of the <span class="nctnt ncbi-func">GetTypeInfo()</span> functions for different types. [Table 2](#table-2) lists six <span class="nctnt ncbi-macro">BEGIN\_NAMED\_\*\_INFO</span> macros, along with a description of the type of object each can be applied to and its expected arguments. Each macro in Table 2 has a corresponding <span class="nctnt ncbi-macro">END\_\*\_INFO</span> macro definition.

Table 2. BEGIN\_NAMED\_\* Macro names and their usage

| Macro name                                                            | Used for                  | Arguments                                  |
|-----------------------------------------------------------------------|---------------------------|--------------------------------------------|
| [BEGIN\_NAMED\_CLASS\_INFO](#-beginnamedclassinfo-)                   | Non-abstract class object | ClassAlias, ClassName                      |
| [BEGIN\_NAMED\_ABSTRACT\_CLASS\_INFO](#-beginnamedabstractclassinfo-) | Abstract class object     | ClassAlias, ClassName                      |
| [BEGIN\_NAMED\_DERIVED\_CLASS\_INFO](#-beginnamedderivedclassinfo-)   | Derived subclass object   | ClassAlias, ClassName, BaseClassName       |
| [BEGIN\_NAMED\_CHOICE\_INFO](#-beginnamedchoiceinfo-)                 | C++ class choice object   | ClassAlias, ClassName                      |
| [BEGIN\_NAMED\_ENUM\_INF](#-beginnamedenuminf-)                       | Enum object               | EnumAlias, EnumName, IsInteger             |
| [BEGIN\_NAMED\_ENUM\_IN\_INFO](#-beginnamedenumininfo-)               | internal Enum object      | EnumAlias, CppContext, EnumName, IsInteger |

The first four macros in Table 2 apply to C++ objects. The <span class="nctnt ncbi-macro">DECLARE\_INTERNAL\_TYPE\_INFO()</span> macro **must** appear in the class definition's public section. These macros take two <span class="nctnt ncbi-type">string</span> arguments:

-   an external alias for the type, and

-   the internal C++ symbolic class name

The next two macros implement global, uniquely named functions which provide access to type information for C++ enumerations; the resulting functions are named <span class="nctnt ncbi-code">GetTypeInfo\_enum\_[EnumName]</span>. The <span class="nctnt ncbi-macro">DECLARE\_ENUM\_INFO()</span> or <span class="nctnt ncbi-macro">DECLARE\_ENUM\_INFO\_IN()</span> macro should be used in these cases to declare the <span class="nctnt ncbi-func">GetTypeInfo\*()</span> functions.

The usage of these six macros generally takes the following form:

    BEGIN_*_INFO(ClassName)
    {
        ADD_*(MemberName1);
        ADD_*(MemberName2);
        ...
    }
    END_*_INFO

That is, the <span class="nctnt ncbi-macro">BEGIN/END</span> macros are used to generate the function's signature and enclosing block, and various <span class="nctnt ncbi-macro">ADD\_\*</span> macros are applied to add information about internal members and class relations.

#### List of the BEGIN\_/END\_ macros

-   [BEGIN\_NAMED\_CLASS\_INFO (ClassAlias, ClassName)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_CLASS_INFO)

-   [BEGIN\_CLASS\_INFO (ClassName)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_CLASS_INFO)

These macros should be used on classes that do not contain any pure virtual functions. For example, the <span class="nctnt ncbi-func">GetTypeInfo()</span> method for the [CPerson](#cperson) class (used in the chapter on iterators) can be implemented as:

    BEGIN_NAMED_CLASS_INFO("CPerson", CPerson)
    {
        ADD_NAMED_STD_MEMBER("m_Name", m_Name); 
        ADD_NAMED_STD_MEMBER("m_Addr", m_Addr); 
        ADD_NAMED_MEMBER("m_NextDoor", m_NextDoor, POINTER, (CLASS, (CPerson)));
    }
    END_CLASS_INFO

or, equivalently, as:

    BEGIN_CLASS_INFO(CPerson)
    {
        ADD_STD_MEMBER(m_Name); 
        ADD_STD_MEMBER(m_Addr);
        ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)));
    }
    END_CLASS_INFO

Here, the <span class="nctnt ncbi-class">CPerson</span> class has two <span class="nctnt ncbi-class">string</span> data members, <span class="nctnt ncbi-var">m\_Name</span> and <span class="nctnt ncbi-var">m\_Addr</span>, as well as a pointer to an object of the same type (<span class="nctnt ncbi-type">CPerson\*</span>). All built-in C++ types such as <span class="nctnt ncbi-type">int, float, string</span> etc., use the <span class="nctnt ncbi-macro">ADD\_NAMED\_STD\_MEMBER</span> or <span class="nctnt ncbi-macro">ADD\_STD\_MEMBER</span> macros. These and other macros used to add members are defined in [Specifying internal structure and class inheritance: the ADD\_ macros](#specifying-internal-structure-and-class-inheritance-the-add-macros) and [Table 3](#table-3).

Table 3. ADD\_\* Macros and their usage

| Macro name                            | Usage                                                                                                       | Arguments                                           |
|---------------------------------------|-------------------------------------------------------------------------------------------------------------|-----------------------------------------------------|
| ADD\_NAMED\_STD\_MEMBER               | Add a standard data member to a class                                                                       | MemberAlias, MemberName                             |
| ADD\_NAMED\_CLASS\_MEMBER             | Add an internal class member to a class                                                                     | MemberAlias, MemberName                             |
| ADD\_NAMED\_SUB\_CLASS                | Add a derived subclass to a class                                                                           | SubClassAlias, SubClassName                         |
| ADD\_NAMED\_REF\_MEMBER               | Add a <span class="nctnt ncbi-class">CRef</span> data member to a class                                     | MemberAlias, MemberName, RefClass                   |
| ADD\_NAMED\_ENUM\_MEMBER              | Add an enumerated data member to a class                                                                    | MemberAlias, MemberName, EnumName                   |
| ADD\_NAMED\_ENUM\_IN\_MEMBER          | Add an externally defined enumerated data member to a class                                                 | MemberAlias, MemberName, CppContext, EnumName       |
| ADD\_NAMED\_MEMBER                    | Add a data member of the type specified by <span class="nctnt ncbi-var">TypeMacro</span> to a class         | MemberAlias, MemberName, TypeMacro, TypeMacroArgs   |
| ADD\_NAMED\_STD\_CHOICE\_VARIANT      | Add a standard variant type to a C++ choice object                                                          | VariantAlias, VariantName                           |
| ADD\_NAMED\_REF\_CHOICE\_VARIANT      | Add a <span class="nctnt ncbi-class">CRef</span> variant to a C++ choice object                             | VariantAlias, VariantName, RefClass                 |
| ADD\_NAMED\_ENUM\_CHOICE\_VARIANT     | Add an enumeration variant to a C++ choice object                                                           | VariantAlias, VariantName, EnumName                 |
| ADD\_NAMED\_ENUM\_IN\_CHOICE\_VARIANT | Add an enumeration variant to a C++ choice object                                                           | VariantAlias, VariantName, CppContext, EnumName     |
| ADD\_NAMED\_CHOICE\_VARIANT           | Add a variant of the type specified by <span class="nctnt ncbi-var">TypeMacro</span> to a C++ choice object | VariantAlias, VariantName, TypeMacro, TypeMacroArgs |
| ADD\_ENUM\_VALUE                      | Add a named enumeration value to an <span class="nctnt ncbi-code">enum</span>                               | EnumValName, Value                                  |

-   [BEGIN\_NAMED\_ABSTRACT\_CLASS\_INFO(ClassAlias, ClassName)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_ABSTRACT_CLASS_INFO)

-   [BEGIN\_ABSTRACT\_CLASS\_INFO(ClassName)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_ABSTRACT_CLASS_INFO)

These macros must be used on abstract base classes which contain pure virtual functions. Because these abstract classes cannot be instantiated, special handling is required in order to install their static <span class="nctnt ncbi-func">GetTypeInfo()</span> methods.

-   [BEGIN\_NAMED\_DERIVED\_CLASS\_INFO (ClassAlias, ClassName, BaseClassName)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_DERIVED_CLASS_INFO)

-   [BEGIN\_DERIVED\_CLASS\_INFO (ClassName, BaseClassName)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_DERIVED_CLASS_INFO)

These macros should be used on derived subclasses whose parent classes also have the <span class="nctnt ncbi-func">GetTypeInfo()</span> method implemented. Data members inherited from parent classes should not be included in the derived class type information.

    BEGIN_DERIVED_CLASS_INFO(CA, CBase)
    {
         // ... data members in CA not inherited from CBase
    }
    END_DERIVED_CLASS_INFO

<span class="nctnt highlight">NOTE:</span>The type information for classes derived directly from <span class="nctnt ncbi-class">CObject</span> does **not** however, follow this protocol. In this special case, although the class is derived from <span class="nctnt ncbi-class">CObject</span>, you should **not** use the <span class="nctnt ncbi-macro">DERIVED\_CLASS</span> macros to implement <span class="nctnt ncbi-func">GetTypeInfo()</span>, but instead use the usual <span class="nctnt ncbi-macro">BEGIN\_CLASS\_INFO</span> macro. <span class="nctnt ncbi-class">CObject</span>'s have a slightly different interface to their type information (see [CObjectGetTypeInfo](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CObjectGetTypeInfo)), and apply these macros differently.

-   [BEGIN\_NAMED\_CHOICE\_INFO (ClassAlias, ClassName)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_CHOICE_INFO)

-   [BEGIN\_CHOICE\_INFO (ClassName)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_CHOICE_INFO)

These macros install <span class="nctnt ncbi-func">GetTypeInfo()</span> for C++<span class="nctnt ncbi-monospace">choice</span> objects, which are implemented as C++ classes. See [Choice objects in the C++ Toolkit](#choice-objects-in-the-c++-toolkit) for a description of C++ <span class="nctnt ncbi-monospace">choice</span> objects. Each of the choice variants occurs as a data member in the class, and the macros used to add choice variants ([ADD\_NAMED\_\*\_CHOICE\_VARIANT](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ADD_NAMED_CHOICE_VARIANT)) are used similarly to those which add data members to classes (see discussion of the [ADD\*](#add*) macros below).

-   [BEGIN\_NAMED\_ENUM\_INFO (EnumAlias, EnumName, IsInteger)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_ENUM_INFO)

-   [BEGIN\_ENUM\_INFO (EnumName, IsInteger)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_ENUM_INFO)

In addition to the two arguments used by the <span class="nctnt ncbi-macro">BEGIN\_\*\_INFO</span> macros for classes, a Boolean argument (<span class="nctnt ncbi-func">IsInteger</span>) indicates whether or not the enumeration includes arbitrary integer values or only those explicitly specified.

-   [BEGIN\_NAMED\_ENUM\_IN\_INFO (EnumAlias, CppContext, EnumName, IsInteger)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_NAMED_ENUM_IN_INFO)

-   [BEGIN\_ENUM\_IN\_INFO (CppContext, EnumName, IsInteger)](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=BEGIN_ENUM_IN_INFO)

These macros also implement the type information functions for C++ enumerations --but in this case, the enumeration is defined outside the scope where the macro is applied, so a <span class="nctnt ncbi-monospace">context</span> argument is required. This new argument, <span class="nctnt ncbi-func">CppContext</span>, specifies the C++ class name or external namespace where the enumeration is defined.

Again, when using the above macros to install type information, the corresponding class definitions **must** include a declaration of the static class member function <span class="nctnt ncbi-func">GetTypeInfo()</span> in the class's public section. The <span class="nctnt ncbi-macro">DECLARE\_INTERNAL\_TYPE\_INFO()</span> macro is provided to ensure that the declaration of this method is correct. Similarly, the <span class="nctnt ncbi-macro">DECLARE\_INTERNAL\_ENUM\_INFO</span> and <span class="nctnt ncbi-macro">DECLARE\_ENUM\_INFO</span> macros should be used in the header files where enumerations are defined. The <span class="nctnt ncbi-macro">DECLARE\_ASN\_TYPE\_INFO</span> and <span class="nctnt ncbi-macro">DECLARE\_ASN\_CHOICE\_INFO</span> macros can be used to declare the type information functions for C-style structs and choice nodes.

### Specifying internal structure and class inheritance: the ADD\_ macros

Information about internal class structure and inheritance is specified using the <span class="nctnt ncbi-macro">ADD\_\*</span> macros (see [Table 3](#table-3)). Again, each macro has both a "named" and "unnamed" implementation. The arguments to all of the ADD\_NAMED\_\* macros begin with the external alias and C++ name of the item to be added.

The ADD\_\* macros that take **only** an alias and a name require that the type being added must be either a built-in type or a type defined by the name argument. When adding a <span class="nctnt ncbi-class">CRef</span> data member to a class or choice object however, the class referenced by the <span class="nctnt ncbi-class">CRef</span> must be made explicit with the <span class="nctnt ncbi-var">RefClass</span> argument, which is the C++ class name for the type pointed to.

Similarly, when adding an enumerated data member to a class, the enumeration itself must be explicitly named. For example, if class <span class="nctnt ncbi-class">CMyClass</span> contains a data member <span class="nctnt ncbi-var">m\_MyEnumVal</span> of type <span class="nctnt ncbi-type">EMyEnum</span>, then the BEGIN\_NAMED\_CLASS\_INFO macro for <span class="nctnt ncbi-class">CMyClass</span> should contain the statement:

    ADD_ENUM_MEMBER (m_MyEnumVal, EMyEnum);

or, equivalently:

    ADD_NAMED_ENUM_MEMBER ("m_MyEnumVal", m_MyEnumVal, EMyEnum);

or, to define a "custom" (non-default) external alias:

    ADD_NAMED_ENUM_MEMBER ("m_CustomAlias", m_MyEnumVal, EMyEnum);

Here, <span class="nctnt ncbi-type">EMyEnum</span> is defined in the same namespace and scope as <span class="nctnt ncbi-class">CMyClass</span>. Alternatively, if the enumeration is defined in a different class or namespace (and therefore, then the <span class="nctnt ncbi-macro">ADD\_ENUM\_IN\_MEMBER</span> macro must be used:

    ADD_ENUM_IN_MEMBER (m_MyEnumVal, COtherClassName::, EMyEnum);

In this example, <span class="nctnt ncbi-type">EMyEnum</span> is defined in a class named <span class="nctnt ncbi-class">COtherClassName</span>. The <span class="nctnt ncbi-func">CppContext</span> argument (defined here as <span class="nctnt ncbi-class">COtherClassName::</span>) acts as a scope operator, and can also be used to specify an alternative namespace. The ADD\_NAMED\_ENUM\_CHOICE\_VARIANT and ADD\_NAMED\_ENUM\_IN\_CHOICE\_VARIANT macros are used similarly to provide information about enumerated choice options. The <span class="nctnt ncbi-macro">ADD\_ENUM\_VALUE</span> macro is used to add enumerated values to the enumeration itself, as demonstrated in the above example of the [BEGIN\_NAMED\_ENUM\_INFO](#beginnamedenuminfo-)macro.

The most complex macros by far are those which use the <span class="nctnt ncbi-type">TypeMacro</span> and <span class="nctnt ncbi-var">TypeMacroArgs</span> arguments: <span class="nctnt ncbi-macro">ADD(\_NAMED)\_MEMBER</span> and <span class="nctnt ncbi-macro">ADD(\_NAMED)\_CHOICE\_VARIANT</span>. These macros are more open-ended and allow for more complex specifications. We have already seen one example of using a macro of this type, in the implementation of the <span class="nctnt ncbi-func">GetTypeInfo()</span> method for <span class="nctnt ncbi-class">CPerson</span>:

    ADD_MEMBER(m_NextDoor, POINTER, (CLASS, (CPerson)));

The <span class="nctnt ncbi-macro">ADD\_MEMBER</span> and <span class="nctnt ncbi-macro">ADD\_CHOICE\_VARIANT</span> macros always take at least two arguments:

the internal member (variant) name

the definition of the member's (variant's) type

Depending on the (second) <span class="nctnt ncbi-var">TypeMacro</span> argument, additional arguments may or may not be needed. In this example, the <span class="nctnt ncbi-var">TypeMacro</span> is *POINTER*, which **does require** additional arguments. The <span class="nctnt ncbi-var">TypeMacroArgs</span> here specify that <span class="nctnt ncbi-var">m\_NextDoor</span> is a pointer to a class type whose C++ name is <span class="nctnt ncbi-class">CPerson</span>.

More generally, the remaining arguments depend on the value of <span class="nctnt ncbi-var">TypeMacro</span>, as these parameters complete the type definition. The possible strings which can occur as <span class="nctnt ncbi-var">TypeMacro</span>, along with the additional arguments required for that type, are given in [Table 4](#table-4).

Table 4. Type macros and their arguments

| TypeMacro         | TypeMacroArgs                         |
|-------------------|---------------------------------------|
| CLASS             | (ClassName)                           |
| STD               | (C++ type)                            |
| StringStore       | ()                                    |
| null              | ()                                    |
| ENUM              | (EnumType, EnumName)                  |
| POINTER           | (Type,Args)                           |
| STL\_multiset     | (Type,Args)                           |
| STL\_set          | (Type,Args)                           |
| STL\_multimap     | (KeyType,KeyArgs,ValueType,ValueArgs) |
| STL\_map          | (KeyType,KeyArgs,ValueType,ValueArgs) |
| STL\_list         | (Type,Args)                           |
| STL\_list\_set    | (Type,Args)                           |
| STL\_vector       | (Type,Args)                           |
| STL\_CHAR\_vector | (C++ Char type)                       |
| STL\_auto\_ptr    | (Type,Args)                           |
| CHOICE            | (Type,Args)                           |

The <span class="nctnt ncbi-macro">ADD\_MEMBER</span> macro generates a call to the corresponding <span class="nctnt ncbi-macro">ADD\_NAMED\_MEMBER</span> macro as follows:

    #define ADD_MEMBER(MemberName,TypeMacro,TypeMacroArgs) \
        ADD_NAMED_MEMBER(#MemberName,MemberName,TypeMacro,TypeMacroArgs)

Some examples of using the ADD\_MEMBER macro are:

    ADD_MEMBER(m_X);
    ADD_MEMBER(m_A, STL_auto_ptr, (CLASS, (ClassName)));
    ADD_MEMBER(m_B, STL_CHAR_vector, (char));
    ADD_MEMBER(m_C, STL_vector, (STD, (int)));
    ADD_MEMBER(m_D, STL_list, (CLASS, (ClassName)));
    ADD_MEMBER(m_E, STL_list, (POINTER, (CLASS, (ClassName))));
    ADD_MEMBER(m_F, STL_map, (STD, (long), STD, (string)));

Similarly, the <span class="nctnt ncbi-macro">ADD\_CHOICE\_VARIANT</span> macro generates a call to the corresponding <span class="nctnt ncbi-macro">ADD\_NAMED\_CHOICE\_VARIANT</span> macro. These macros add type information for the [choice object's variants.](#choice-object's-variants)

Runtime Object Type Information
-------------------------------

The following topics are discussed in this section:

-   [Introduction](#introduction)

-   [Motivation](#motivation)

-   [Object Information Classes](#object-information-classes)

-   [Usage of object type information](#usage-of-object-type-information)

### Introduction

Run-time information about data types is necessary in several contexts, including:

1  
When reading, writing, and processing serialized data, where runtime information about a type's internal structure is needed.

2  
When reading from an arbitrary data source, where data members' external aliases must be used to locate the corresponding class data members (e.g.*MyXxx* may be aliased as *my-xxx* in the input data file).

3  
When using a generalized [C++ type iterator](#c++-type-iterator) to traverse the data members of an object.

4  
When accessing the object type information *per se* (without regard to any particular object instance), e.g. to dump it to a file as ASN.1 or DTD specifications (not data).

In the first three cases above, it is necessary to have both the object itself as well as its runtime type information. This is because in these contexts, the object is usually passed inside a generic function, as a pointer to its most base parent type [CObject.](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObject.html) The runtime type information is needed here, as there is no other way to ascertain the actual object's data members. In addition to providing this information, a runtime type information object provides an interface for accessing and modifying these data members.

In case (4) above, the type information is used independent of any actual object instances.

#### Type and Object specific info

The NCBI C++ Toolkit uses two classes to support these requirements:

-   **Type information classes** (base class [CTypeInfo](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCTypeInfo.html)) are intended for internal usage only, and they encode information about a type, devoid of any instances of that type. This information includes the class layout, inheritance relations, external alias, and various other attributes such as size, which are independent of specific instances. Each data member of a class also has its own type information. Thus, in addition to providing information relevant to the member's occurrence in the class (e.g. the member name and offset), the type information for a <span class="nctnt ncbi-monospace">class</span> must also provide access to the type information for each of its <span class="nctnt ncbi-monospace">members</span>. Limited type information is also available for types other than classes, such as primitive data types, enumerations, containers, and pointers. For example, the type information for a primitive type specifies that it is an <span class="nctnt ncbi-type">int, float,</span> or <span class="nctnt ncbi-type">char</span>, etc., and whether or not that element is signed. Enumerations are a special kind of primitive type, whose type information specifies its enumeration values and named elements. Type information for containers specifies both the type of container and the type of elements that it holds.

-   [Object information classes](#object-information-classes) (base class [CObjectTypeInfo](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectTypeInfo.html)) include a pointer to the type information as well as a pointer to the object <span class="nctnt ncbi-type">instance</span>, and provide a safe interface to that object. In situations where type information is used independent of any concrete object, the object information class simply serves as a wrapper to a type information object. Where access to an object instance is required, the object pointer provides direct access to the correctly type-cast instance, and the interface provides methods to access and/or modify the object itself or members of that object.

The C++ Toolkit stores the type information outside any instances of that type, in a statically created <span class="nctnt ncbi-class">CTypeInfo</span> object. For class objects, this <span class="nctnt ncbi-class">CTypeInfo</span> object can be accessed by all instances of the class via a static [GetTypeInfo()](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=GetTypeInfo) class method. Similarly, for primitive types and other constructs that have no way of associating methods with them per se, a static globally defined <span class="nctnt ncbi-func">GetTypeInfoXxx()</span> function is used to access a static <span class="nctnt ncbi-class">CTypeInfo</span> object. (The *Xxx* suffix is used here to indicate that a globally unique name is generated for the function).

All of the automatically generated classes and constructs defined in the C++ Toolkit's [objects/](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects) directory already have static <span class="nctnt ncbi-func">GetTypeInfo()</span> functions implemented for them. In order to make type information about <span class="nctnt ncbi-monospace">user-defined</span> classes and elements also accessible, you will need to implement static <span class="nctnt ncbi-func">GetTypeInfo()</span> functions for these constructs. A number of pre-processor macros are available to support this activity, and are described in the section on [User-defined Type Information](#user-defined-type-information).

Type information is often needed when the object itself has been passed anonymously, or as a pointer to its parent class. In this case, it is not possible to invoke the <span class="nctnt ncbi-func">GetTypeInfo()</span> method directly, as the object's exact type is unknown. Using a <span class="nctnt ncbi-code">\<static\_cast\></span> operator to enable the member function is also unsafe, as it may open the door to incorrectly associating an object's pointer with the wrong type information. For these reasons, the <span class="nctnt ncbi-class">CTypeInfo</span> class is intended for internal usage only, and it is the [CObjectTypeInfo](#cobjecttypeinfo) classes that provide a more safe and friendly user interface to type information.

### Motivation

We use a simple example to help motivate the use of this <span class="nctnt ncbi-monospace">type</span> and <span class="nctnt ncbi-monospace">object</span> information model. Let us suppose that we would like to have a generic function <span class="nctnt ncbi-func">LoadObject()</span>, which can populate an object using data read from a flat file. For example, we might like to have:

    bool LoadObject(Object& myObj, istream& is);

where <span class="nctnt ncbi-var">myObj</span> is an instance of some subclass of <span class="nctnt ncbi-class">Object</span>. Assuming that the text in the file is of the form:

    MemberName1 value1
    MemberName5 value5
    MemberName2 value2
    :

we would like to find the corresponding data member in <span class="nctnt ncbi-var">myObj</span> for each <span class="nctnt ncbi-var">MemberName</span>, and set that data member's value accordingly. Unfortunately, <span class="nctnt ncbi-var">myObj</span> cannot directly supply any useful type information, as the member names we seek are for a specific subclass of <span class="nctnt ncbi-class">Object</span>. Now suppose that we have an appropriate type information object available for <span class="nctnt ncbi-var">myObj</span>, and consider how this might be used:

    bool LoadObject(TypeInfo& info, Object& myObj, istream& is)
    {
        string myName, myValue;

        while ( !is.eof() ) {
            is >> myName >> myValue;
            void* member = FindMember(info, myObj, myName);
            AssignValue(member, myValue);
        }
    }

Here, we assume that our type information object, <span class="nctnt ncbi-var">info</span>, stores information about the memory offset of each data member in <span class="nctnt ncbi-var">myObj</span>, and that such information can be retrieved using some sort of identifying member name such as <span class="nctnt ncbi-var">myName</span>. This is not too difficult to imagine, and indeed, this is exactly the type of information and facility provided by the C++ Toolkit's type information classes. The <span class="nctnt ncbi-func">FindMember()</span> function just needs to return a <span class="nctnt ncbi-type">void</span> pointer to the appropriate location in memory. The <span class="nctnt ncbi-func">AssignValue()</span> function presents a much greater challenge however, as its two sole arguments are a <span class="nctnt ncbi-type">void</span> pointer and a <span class="nctnt ncbi-class">string</span>. This would be fine if the data member was indeed a <span class="nctnt ncbi-type">void</span> pointer, and a <span class="nctnt ncbi-class">string</span> value was acceptable. In general this is not the case, and stronger methods are clearly needed.

In particular, for each data member encountered, we need to retrieve the type of that member as well as its location in memory, so as to process <span class="nctnt ncbi-var">myValue</span> appropriately before assigning it. In addition, we need safer mechanisms for making such "untyped" assignments. Ideally, we would like a <span class="nctnt ncbi-func">FindMember()</span> function that returns a correctly cast pointer to that data member, along with its associated type information. This is what the [object information classes](#object-information-classes) provide - a pointer to the object instance as well as a pointer to its static <span class="nctnt ncbi-monospace">type</span> information. The interface to the <span class="nctnt ncbi-class">object</span> information class also provides a number of methods such as <span class="nctnt ncbi-func">GetClassMember(), GetTypeFamily(), SetPrimitiveValue()</span>, etc., to support the type of activity described above.

### Object Information Classes

The following topics are discussed in this section:

-   [CObjectTypeInfo (\*)](#cobjecttypeinfo-*)

-   [CConstObjectInfo (\*)](#cconstobjectinfo-*)

-   [CObjectInfo (\*)](#cobjectinfo-*)

#### <span class="nctnt ncbi-class">CObjectTypeInfo</span> ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectTypeInfo.html))

This is the base class for all <span class="nctnt ncbi-monospace">object</span> information classes. It is intended for usage where there is no concrete object being referenced, and all that is required is access to the type information. A <span class="nctnt ncbi-class">CObjectTypeInfo</span> contains a pointer to a low-level <span class="nctnt ncbi-class">CTypeInfo</span> object, and functions as a user-friendly wrapper class.

The constructor for <span class="nctnt ncbi-class">CObjectTypeInfo</span> takes a pointer to a <span class="nctnt ncbi-code">const CTypeInfo</span> object as its single argument. This is precisely what is returned by all of the static <span class="nctnt ncbi-func">GetTypeInfo()</span> functions. Thus, to create a <span class="nctnt ncbi-class">CObjectTypeInfo</span> for the <span class="nctnt ncbi-class">CBioseq</span> class - without reference to any particular instance of <span class="nctnt ncbi-class">CBioseq</span> - one might use:

<span class="nctnt ncbi-code">CObjectTypeInfo objInfo( CBioseq::GetTypeInfo() );</span>

One of the most important methods provided by the <span class="nctnt ncbi-class">CObjectTypeInfo</span> class interface is <span class="nctnt ncbi-func">GetTypeFamily()</span>, which returns an enumerated value indicating the <span class="nctnt ncbi-monospace">type family</span> for the object of interest. Five type families are defined by the [ETypeFamily](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=ETypeFamily) enumeration:

    ETypeFamily GetTypeFamily(void) const;
        enum ETypeFamily {
        eTypeFamilyPrimitive,
        eTypeFamilyClass,
        eTypeFamilyChoice,
        eTypeFamilyContainer,
        eTypeFamilyPointer
    };

Different queries become appropriate depending on the <span class="nctnt ncbi-type">ETypeFamily</span> of the object. For example, if the object is a container, one might need to determine the type of container (e.g. whether it is a <span class="nctnt ncbi-class">list</span>, <span class="nctnt ncbi-class">map</span> etc.), and the type of element. Similarly, if an object is a primitive type (e.g. <span class="nctnt ncbi-type">int, float, string, </span>etc.), an appropriate query becomes what the value type is, and in the case of integer-valued types, whether or not it is signed. Finally, in the case of more complex objects such as class and choice objects, access to the type information for the individual data members and choice variants is needed. The following methods are included in the <span class="nctnt ncbi-class">CObjectTypeInfo</span> interface for these purposes:

For objects with family type <span class="nctnt ncbi-code">eTypeFamilyPrimitive</span>:

    EPrimitiveValueType GetPrimitiveValueType(void) const;
    bool IsPrimitiveValueSigned(void) const;

For objects with family type <span class="nctnt ncbi-code">eTypeFamilyClass</span>:

    CMemberIterator BeginMembers(void) const;
    CMemberIterator FindMember(const string& memberName) const;
    CMemberIterator FindMemberByTag(int memberTag) const;

For objects with family type <span class="nctnt ncbi-code">eTypeFamilyChoice</span>:

    CVariantIterator BeginVariants(void) const;
    CVariantIterator FindVariant(const string& memberName) const;
    CVariantIterator FindVariantByTag(int memberTag) const;

For objects with family type <span class="nctnt ncbi-code">eTypeFamilyContainer</span>:

    EContainerType GetContainerType(void) const;
    CObjectTypeInfo GetElementType(void) const;

For objects with family type <span class="nctnt ncbi-code">eTypeFamilyPointer</span>:

    CObjectTypeInfo GetPointedType(void) const;

The two additional enumerations referred to here, [EContainerType](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EContainerType) and [EPrimitiveValueType](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=EPrimitiveValueType), are defined, along with <span class="nctnt ncbi-type">ETypeFamily</span>, in [include/serial/serialdef.hpp](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/serial/serialdef.hpp).

Different iterator classes are used for iterating over class data members versus choice variant types. Thus, if the object of interest is a C++ class object, then access to the type information for its members can be gained using a <span class="nctnt ncbi-class">CObjectTypeInfo::CMemberIterator</span>. The <span class="nctnt ncbi-func">BeginMembers()</span> method returns a <span class="nctnt ncbi-class">CMemberIterator</span> pointing to the first data member in the class; the <span class="nctnt ncbi-func">FindMember\*()</span> methods return a <span class="nctnt ncbi-class">CMemberIterator</span> pointing to a data member whose name or tag matches the input argument. The <span class="nctnt ncbi-class">CMemberIterator</span> class is a forward iterator whose operators are defined as follows:

-   the <span class="nctnt ncbi-code">++</span> operator increments the iterator (makes it point to the next class member)

-   the <span class="nctnt ncbi-code">()</span> operator tests that the iterator has not exceeded the legitimate range

-   the <span class="nctnt ncbi-code">\*</span> dereferencing operator returns a <span class="nctnt ncbi-class">CObjectTypeInfo</span> for the data member the iterator currently points to

Similarly, the <span class="nctnt ncbi-func">BeginVariants()</span> and <span class="nctnt ncbi-func">FindVariant()</span> methods allow iteration over the choice variant data types for a choice class, and the dereferencing operation yields a <span class="nctnt ncbi-class">CObjectTypeInfo</span> object for the choice variant currently pointed to by the iterator.

#### CConstObjectInfo ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCConstObjectInfo.html))

The <span class="nctnt ncbi-class">CConstObjectInfo</span> (derived from [CObjectTypeInfo](#cobjecttypeinfo)) adds an interface to access the particular instance of an object (in addition to the interface inherited from [CObjectTypeInfo](#cobjecttypeinfo), which provides access to type information only). It is intended for usage with <span class="nctnt ncbi-code">const</span> instances of the object of interest, and therefore the interface does not permit any modifications to the object. The constructor for <span class="nctnt ncbi-class">CConstObjectInfo</span> takes two arguments:

    CConstObjectInfo(const void* instancePtr, const CTypeInfo* typeinfoPtr);

(Alternatively, the constructor can be invoked with a single STL pair containing these two objects.)

Each <span class="nctnt ncbi-class">CConstObjectInfo</span> contains a pointer to the object's type information as well as a pointer to an instance of the object. The existence or validity of this instance can be checked using any of the following <span class="nctnt ncbi-class">CConstObjectInfo</span> methods and operators:

-   <span class="nctnt ncbi-code">bool Valid(void) const;</span>

-   <span class="nctnt ncbi-code">operator bool(void) const;</span>

-   <span class="nctnt ncbi-code">bool operator!(void) const;</span>

For <span class="nctnt ncbi-monospace">primitive</span> type objects, the <span class="nctnt ncbi-class">CConstObjectInfo</span> interface provides access to the currently assigned value using <span class="nctnt ncbi-func">GetPrimitiveValueXxx()</span>. Here, <span class="nctnt ncbi-var">Xxx</span> may be <span class="nctnt ncbi-monospace">Bool, Char, Long, ULong, Double, String, ValueString</span>, or <span class="nctnt ncbi-monospace">OctetString</span>. In general, to get a primitive value, one first applies a <span class="nctnt ncbi-code">switch</span> statement to the value returned by <span class="nctnt ncbi-func">GetPrimitiveValueType()</span>, and then calls the appropriate <span class="nctnt ncbi-func">GetPrimitiveValueXxx()</span> method depending on the branch followed, e.g.:

    switch ( obj.GetPrimitiveValueType() ) {
    case ePrimitiveValueBool:
        bool b = obj.GetPrimitiveValueBool();
        break;

    case ePrimitiveValueInteger:
        if ( obj.IsPrimitiveValueSigned() ) {
            long l = obj.GetPrimitiveValueLong();
        } else {
            unsigned long ul = obj.GetPrimitiveValueULong();
        }
        break;
        //... etc.
    }

Member iterator methods are also defined in the <span class="nctnt ncbi-class">CConstObjectInfo</span> class, with a similar interface to that found in the <span class="nctnt ncbi-class">CObjectTypeInfo</span> class. In this case however, the dereferencing operators return a <span class="nctnt ncbi-class">CConstObjectInfo</span> object - not a <span class="nctnt ncbi-class">CObjectTypeInfo</span> object - for the current member. For C++<span class="nctnt ncbi-code">class</span> objects, these member functions are:

-   <span class="nctnt ncbi-code">CMemberIterator BeginMembers(void) const;</span>

-   <span class="nctnt ncbi-code">CMemberIterator FindClassMember(const string& memberName) const;</span>

-   <span class="nctnt ncbi-code">CMemberIterator FindClassMemberByTag(int memberTag) const;</span>

For C++ choice objects, only one variant is ever selected, and only that choice variant is instantiated. As it does not make sense to define a <span class="nctnt ncbi-code">CConstObjectInfo iterator</span> for uninstantiated variants, the method <span class="nctnt ncbi-func">GetCurrentChoiceVariant()</span> is provided instead. The dereferencing operator (\*) can be applied to the object returned by this method to obtain a <span class="nctnt ncbi-class">CConstObjectInfo</span> for the variant. Of course, type information for unselected variants can still be accessed using the <span class="nctnt ncbi-class">CObjectTypeInfo</span> methods.

The <span class="nctnt ncbi-class">CConstObjectInfo</span> class also defines an element iterator for container type objects. <span class="nctnt ncbi-class">CConstObjectInfo::CElementIterator</span> is a forward iterator whose interface includes increment and testing operators. Dereferencing is implemented by the iterator's <span class="nctnt ncbi-func">GetElement()</span> method, which returns a <span class="nctnt ncbi-class">CConstObjectInfo</span> for the element currently pointed to by the iterator.

Finally, for pointer type objects, the type returned by the method <span class="nctnt ncbi-func">GetPointedObject()</span> is also a <span class="nctnt ncbi-class">CConstObjectInfo</span> for the object - not just a <span class="nctnt ncbi-class">CObjectTypeInfo</span>.

#### CObjectInfo ([\*](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectInfo.html))

The <span class="nctnt ncbi-class">CObjectInfo</span> class is in turn derived from <span class="nctnt ncbi-class">CConstObjectInfo</span>, and is intended for usage with <span class="nctnt ncbi-code">mutable</span> instances of the object of interest. In addition to all of the methods inherited from the parent class, the interface to this class also provides methods that allow modification of the object itself or its data members.

For primitive type objects, a set of <span class="nctnt ncbi-func">SetPrimitiveValueXxx()</span> methods are available, complimentary to the <span class="nctnt ncbi-func">GetPrimitiveValueXxx()</span> methods described above. Methods that return member iterator objects are again reimplemented, and the de-referencing operators now return a <span class="nctnt ncbi-class">CObjectInfo</span> object for that data member. As the <span class="nctnt ncbi-class">CObjectInfo</span> now points to a <span class="nctnt ncbi-code">mutable</span> object, these iterators can be used to set values for the data member. Similarly, <span class="nctnt ncbi-func">GetCurrentChoiceVariant()</span> now returns a <span class="nctnt ncbi-class">CObjectInfo</span>, as does <span class="nctnt ncbi-code">CObjectInfo::CElementIterator::GetElement()</span>.

### Usage of object type information

We can now reconsider how our LoadObject() function might be implemented using the <span class="nctnt ncbi-class">CObjectInfo</span> class:

    bool LoadObject(CObjectInfo& info, CNcbiIStream& is)
    {
        string alias, myValue;

        while ( !is.eof() ) {
            is >> alias >> myValue;

            CObjectInfo dataMember(*info.FindClassMember(alias));
            if (!dataMember) {
                ERR_POST_X(1, "Couldn't find member named:" << alias);
            }
            SetValue(dataMember, myValue);
        }
    }

Here, <span class="nctnt ncbi-var">info</span> contains pointers to the <span class="nctnt ncbi-class">CObject</span> itself as well as to its associated <span class="nctnt ncbi-class">CTypeInfo</span> object. For each member alias read from the file, we apply <span class="nctnt ncbi-code">FindClassMember(alias)</span>, and dereference the returned iterator to retrieve a <span class="nctnt ncbi-class">CObjectInfo</span> object for that member. We then use the operator <span class="nctnt ncbi-code">()</span> to verify that the member was located, and if so, use the member's <span class="nctnt ncbi-class">CObjectInfo</span> to set a value in the function <span class="nctnt ncbi-func">SetValue()</span>:

    void SetValue(const CObjectInfo& obj, const string value)
    {
        if (obj.GetTypeFamily() == eTypeFamilyPrimitive) {

            switch ( obj.GetPrimitiveValueType() ) {

            case ePrimitiveValueBool:
                obj.SetPrimitiveValueBool (atoi (value.c_str()));
                break;

            case ePrimitiveValueChar:
                obj.SetPrimitiveValueChar (value.c_str()[0]);
                break;

            //... etc
            }
        } else {
            ERR_POST_X(2, "Attempt to assign non-primitive from string:" << value);
        }
    }

In this example, <span class="nctnt ncbi-func">SetValue()</span> can only assign primitive types. More generally however, the <span class="nctnt ncbi-class">CObjectInfo</span> class allows the assignment of more complex types that are simply not implemented here. Note also that the arguments to <span class="nctnt ncbi-func">SetValue()</span> are <span class="nctnt ncbi-code">const</span>, even though the function **does** modify the value of the data instance pointed to. In particular, the type <span class="nctnt ncbi-code">const CObjectInfo</span> should not be confused with the type <span class="nctnt ncbi-class">CConstObjectInfo</span>. The former specifies that object information construct is non-mutable, although the instance it points to can be modified. The latter specifies that the instance itself is non-mutable.

In addition to user-specific applications of the type demonstrated in this example, the generic implementations of the [C++ type iterators](#c++-type-iterators) and the [CObject[IO]Stream](#cobjectiostream)class methods provide excellent examples of how runtime object type information can be deployed.

As a final example of how type information might be used, we consider an application whose simple task is to translate a data file on an input stream to a different format on an output stream. One important use of the object classes defined in <span class="nctnt ncbi-path">include/objects</span> is the hooks and parsing mechanisms available to applications utilizing [CObject[IO]Streams](#cobjectiostreams). The stream objects specialize in different formats (such as XML or ASN.1), and must work in concert with these type-specific object classes to interpret or generate serialized data. In some cases however, the dynamic memory allocation required for large objects may be substantial, and it is preferable to avoid actually instantiating a whole object all at once.

Instead, it is possible to use the [CObjectStreamCopier](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectStreamCopier.html) class, described in [CObject[IO]Streams](#cobjectiostreams). Briefly, this class holds two <span class="nctnt ncbi-class">CObject[IO]Stream</span> data members pointing to the input and output streams, and a set of <span class="nctnt ncbi-code">Copy</span> methods which take a <span class="nctnt ncbi-class">CTypeInfo</span> argument. Using this class, it is easy to translate files between different formats; for example:

    auto_ptr<CObjectIStream>  in(CObjectIStream::Open("mydata.xml",eSerial_Xml));
    auto_ptr<CObjectOStream> out(CObjectOStream::Open("mydata.asn",eSerial_AsnBinary));
    CObjectStreamCopier copier(*in, *out);
    copier.Copy (CBioseq_set::GetTypeInfo());

copies a <span class="nctnt ncbi-class">CBioseq\_set</span> encoded in XML to a new file, reformatted in ASN.1 binary format.

Choice objects in the NCBI C++ Toolkit
--------------------------------------

The following topics are discussed in this section:

-   [Introduction](#introduction)

-   [C++ choice objects](#c++-choice-objects)

### Introduction

The [datatool](ch_app.html#ch_app.datatool) program processes the ASN.1 specification files (<span class="nctnt ncbi-path">\*.asn</span>) in the [src/objects/](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects) directories to generate the associated C++ class definitions. The corresponding program implemented in the C Toolkit, <span class="nctnt ncbi-app">asntool</span>, used the ASN.1 specifications to generate C enums, structs, and functions. In contrast, <span class="nctnt ncbi-app">datatool</span> must generate C++ enums, classes and methods. In addition, for each defined object type, <span class="nctnt ncbi-app">datatool</span> must also generate the associated [type information](#type-information) method or function.

There is a significant difference in how these two tools implement ASN.1 <span class="nctnt ncbi-monospace">choice</span> elements. As an example, consider the following ASN.1 specification:

    Object-id ::= CHOICE {
        id INTEGER,
        str VisibleString
    }

The ASN.1 <span class="nctnt ncbi-monospace">choice</span> element specifies that the corresponding object may be any one of the listed types. In this case, the possible types are an integer and a string. The approach used in <span class="nctnt ncbi-app">asntool</span> was to implement all choice objects as <span class="nctnt ncbi-type">ValNode</span>s, which were in turn defined as:

    typedef struct valnode {
        unsigned choice;
        DataVal data;
        struct valnode *next;
    } ValNode;

The <span class="nctnt ncbi-type">DataVal</span> field is a <span class="nctnt ncbi-code">union</span>, which may directly store numerical values, or alternatively, hold a <span class="nctnt ncbi-type">void</span> pointer to a character string or C <span class="nctnt ncbi-code">struct</span>. Thus, to process a <span class="nctnt ncbi-monospace">choice</span> element in the C Toolkit, one could first retrieve the <span class="nctnt ncbi-monospace">choice</span> field to determine how the data should be interpreted, and subsequently, retrieve the data via the <span class="nctnt ncbi-type">DataVal</span> field. In particular, no explicit implementation of individual choice objects was used, and it was left to functions which manipulate these elements to enforce logical consistency and error checking for legitimate values. A C <span class="nctnt ncbi-code">struct</span> which included a <span class="nctnt ncbi-monospace">choice</span> element as one of its fields merely had to declare that element as type *ValNode*. This design was further complicated by the use of a <span class="nctnt ncbi-type">void</span> pointer to store non-primitive types such as <span class="nctnt ncbi-code">struct</span>s or character strings.

In contrast, the C++ <span class="nctnt ncbi-app">datatool</span> implementation of <span class="nctnt ncbi-monospace">choice</span> elements defines a class with built-in, automatic error checking for each <span class="nctnt ncbi-monospace">choice</span> object. The usage of [CObject](ch_core.html#ch_core.CRef) class hierarchy (and the associated [type information](#type-information) methods) solves many of the problems associated with working with <span class="nctnt ncbi-type">void</span> pointers.

### C++ choice objects

The classes generated by <span class="nctnt ncbi-app">datatool</span> for <span class="nctnt ncbi-monospace">choice</span> elements all have the following general structure:

    class C[AsnChoiceName] : public CObject
    {
    public:
        ...                                 // constructors and destructors
        DECLARE_INTERNAL_TYPE_INFO();       // declare GetTypeInfo() method
        enum E_Choice {                     // enumerate the class names
           e_not_set,                       // for the choice variants
           e_Xxx,
           ...
        };
        typedef CXxx TXxx;                  // typedef each variant class
        ...
        virtual void Reset(void);           // reset selection to none
        E_Choice Which(void) const;         // return m_choice
        void Select(E_Choice index,         // change the current selection
                    EResetVariant reset);
        static string SelectionName(E_Choice index);
        bool IsXxx(void) const;             // true if m_choice == eXxx
        CXxx& GetXxx(void);
        const CXxx& GetXxx(void) const;
        CXxx& SetXxx(void);
        void SetXxx(const CRef<CXxx>& ref);
        ...
    private:
        E_Choice m_choice;                  // choice state
        union {
           TXxx m_Xxx;
           ...
        };
        CObject *m_object;                  // variant's data
        ...
    };

For the above ASN.1 specification, <span class="nctnt ncbi-app">datatool</span> generates a class named <span class="nctnt ncbi-class">CObject\_id</span>, which is derived from [CObject](ch_core.html#ch_core.CObject). For each choice variant in the specification, an enumerated value (in <span class="nctnt ncbi-type">E\_Choice</span>), and an internal <span class="nctnt ncbi-code">typedef</span> are defined, and a declaration in the <span class="nctnt ncbi-code">union</span> data member is made. For this example then, we would have:

    enum E_Choice {
        e_not_set,
        e_Id,
        e_Str
    };
    ...
    typedef int TId;
    typedef string TStr;
    ...
    union {
        TId m_Id;
        string *m_string;
    };

In this case both of the choice variants are C++ built-in types. More generally however, the choice variant types may refer to any type of object. For convenience, we refer to their C++ type names here as "CXxx",

Two private data members store information about the currently selected choice variant: <span class="nctnt ncbi-var">m\_choice</span> holds the <span class="nctnt ncbi-code">enum</span> value, and <span class="nctnt ncbi-var">m\_Xxx</span> holds (or points to a <span class="nctnt ncbi-class">CObject</span> containing) the variant's data. The choice object's member functions provide access to these two data members. <span class="nctnt ncbi-func">Which()</span> returns the currently selected variant's <span class="nctnt ncbi-code">E\_Choice enum</span> value. Each choice variant has its own <span class="nctnt ncbi-func">Get()</span> and <span class="nctnt ncbi-func">Set()</span> methods. Each <span class="nctnt ncbi-func">GetXxx()</span> method throws an exception if the variant type for that method does not correspond to the current selection type. Thus, it is not possible to unknowingly retrieve the incorrect type of choice variant.

<span class="nctnt ncbi-code">Select(e\_Xxx)</span> uses a <span class="nctnt ncbi-code">switch(e\_Xxx)</span> statement to initialize <span class="nctnt ncbi-var">m\_Xxx</span> appropriately, sets <span class="nctnt ncbi-var">m\_choice</span> to <span class="nctnt ncbi-var">e\_Xxx</span>, and returns. Two <span class="nctnt ncbi-func">SetXxx()</span> methods are defined, and both use this <span class="nctnt ncbi-func">Select()</span> method. <span class="nctnt ncbi-func">SetXxx()</span> with no arguments calls <span class="nctnt ncbi-code">Select(e\_Xxx)</span> and returns <span class="nctnt ncbi-var">m\_Xxx</span> (as initialized by <span class="nctnt ncbi-func">Select()</span>). <span class="nctnt ncbi-func">SetXxx(TXxx& value)</span> also calls <span class="nctnt ncbi-code">Select(e\_Xxx)</span> but resets <span class="nctnt ncbi-var">m\_Xxx</span> to <span class="nctnt ncbi-var">value</span> before returning.

Some example choice objects in the C++ Toolkit are:

-   [CDate](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCDate.html)

-   [CInt\_fuzz](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCInt__fuzz.html)

-   [CObject\_id](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObject__id.html)

-   [CPerson\_id](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCPerson__id.html)

-   [CAnnotdesc](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCAnnotdesc.html)

-   [CSeq\_annot](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCSeq__annot.html)

Traversing a Data Structure
---------------------------

The following topics are discussed in this section:

-   [Locating the Class Definitions](#locating-the-class-definitions)

-   [Accessing and Referencing Data Members](#accessing-and-referencing-data-members)

-   [Traversing a Biostruc](#traversing-a-biostruc)

-   [Iterating Over Containers](#iterating-over-containers)

### Locating the Class Definitions

In general, traversing through a class object requires that you first become familiar with the internal class structure and member access functions for that object. In this section we consider how you can access this information in the source files, and apply it. The example provided here involves a <span class="nctnt ncbi-type">Biostruc</span> type which is implemented by class [CBiostruc](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc.html), and its base (parent) class, [CBiostruc\_Base.](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc__Base.html)

The first question is: how do I locate the class definitions implementing the object to be traversed? There are now two source browsers which you can use. To obtain a synopsis of the class, you can search the [index](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classes.html) or the [class hierarchy](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/hierarchy.html) of the *Doc++* browser and follow a link to the class. For example, a synopsis of the [CBiostruc](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc.html) class is readily available. From this page, you can also access the relevant source files archived by the*LXR* browser, by following the [Locate CBiostruc](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBiostruc) link. Alternatively, you may want to access the *LXR* engine directly by using the [Identifier search](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBiostruc) tool.

Because we wish to determine which headers to include, the synopsis displayed by the [Identifier search](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBiostruc) tool is most useful. There we find a single header file, [Biostruc.hpp](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb1/Biostruc.hpp), listed as defining the class. Accordingly, this is the header file we must include. The <span class="nctnt ncbi-class">CBiostruc</span> class inherits from the <span class="nctnt ncbi-class">CBiostruc\_Base</span> class however, and we will need to consult that file as well to understand the internal structure of the <span class="nctnt ncbi-class">CBiostruc</span> class. Following a link to the parent class from the class hierarchy browser, we find the definition of the [CBiostruc\_Base](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc__Base.html) class.

This is where we must look for the definitions and access functions we will be using. However, it is the <span class="nctnt ncbi-monospace">derived user class</span> (<span class="nctnt ncbi-class">CBiostruc</span>) whose header should be included in your source files, and which should be instantiated by your local program variable. For a more general discussion of the relationship between the base parent objects and their derived user classes, see [Working with the serializable object classes.](ch_proj.html#ch_proj.base_classes)

### Accessing and Referencing Data Members

Omitting some of the low-level details of the base class, we find the <span class="nctnt ncbi-class">CBiostruc\_Base</span> class has essentially the following structure:

    class CBiostruc_Base : public CObject
    {
    public:
        // type definitions
        typedef list< CRef<CBiostruc_id> > TId;
        typedef list< CRef<CBiostruc_descr> > TDescr;
        typedef list< CRef<CBiostruc_feature_set> > TFeatures;
        typedef list< CRef<CBiostruc_model> > TModel;
        typedef CBiostruc_graph TChemical_graph;
        // Get() members
        const TId& GetId(void) const;
        const TDescr& GetDescr(void) const;
        const TChemical_graph& GetChemical_graph(void) const;
        const TFeatures& GetFeatures(void) const;
        const TModel& GetModel(void) const;
        // Set() members
        TId& SetId(void);
        TDescr& SetDescr(void);
        TChemical_graph& SetChemical_graph(void);
        TFeatures& SetFeatures(void);
        TModel& SetModel(void);
    private:
        TId m_Id;
        TDescr m_Descr;
        TChemical_graph m_Chemical_graph;
        TFeatures m_Features;
        TModel m_Model;
    };

With the exception of the structure's chemical graph, each of the class's private data members is actually a <span class="nctnt ncbi-class">list</span> of references (pointers), as specified by the type definitions. For example, <span class="nctnt ncbi-type">TId</span> is a list of [CRef](ch_core.html#ch_core.CRef) objects, where each <span class="nctnt ncbi-class">CRef</span> object points to a [CBiostruc\_id](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCBiostruc__id.html). The <span class="nctnt ncbi-class">CRef</span> class is a type of smart pointer used to hold a pointer to a reference-counted object. The dereferencing operator, when applied to a (dereferenced) iterator pointing to an element of <span class="nctnt ncbi-type">CBiostruc::TId</span>, e.g. <span class="nctnt ncbi-code">\*\*CRef\_i</span>, will return a <span class="nctnt ncbi-class">CBiostruc\_id</span>. Thus, the call to <span class="nctnt ncbi-func">GetId()</span> returns a list which must then be iterated over and dereferenced to get the individual <span class="nctnt ncbi-class">CBiostruc\_id</span> objects. In contrast, the function <span class="nctnt ncbi-func">GetChemicalGraph()</span> returns the object directly, as it does not involve a <span class="nctnt ncbi-class">list</span> or a <span class="nctnt ncbi-class">CRef</span>.

NOTE: It is strongly recommended that you use type names defined in the generated classes (e.g. <span class="nctnt ncbi-type">TId</span>, <span class="nctnt ncbi-type">TDescr</span>) rather than generic container names (<span class="nctnt ncbi-class">list\< CRef\<CBiostruc\_id\> \></span> etc.). The real container class may change occasionally and you will have to modify the code using generic container types every time it happens. When iterating over a container it's recommended to use <span class="nctnt ncbi-macro">ITERATE</span> and <span class="nctnt ncbi-macro">NON\_CONST\_ITERATE</span> macros.

The <span class="nctnt ncbi-func">GetXxx()</span> and <span class="nctnt ncbi-func">SetXxx()</span> member functions define the user interface to the class, providing methods to access and modify ("mutate") private data. In addition, most classes, including <span class="nctnt ncbi-class">CBiostruc</span>, have <span class="nctnt ncbi-func">IsSetXxx()</span> and <span class="nctnt ncbi-func">ResetXxx()</span> methods to validate and clear the data members, respectively.

### Traversing a Biostruc

The program <span class="nctnt ncbi-path">traverseBS.cpp</span> (see [Code Sample 4](#code-sample-4)) demonstrates how one might load a serial data file and iterate over the components of the resulting object. This example reads from a text ASN.1 Biostruc file and stores the information into a <span class="nctnt ncbi-class">CBiostruc</span> object in memory. The overloaded <span class="nctnt ncbi-func">Visit()</span> function is then used to recursively examine the object <span class="nctnt ncbi-code">CBiostruc bs</span> and its components.

#### Code Sample 4. traverseBS.cpp

    // File name: traverseBS.cpp
    // Description: Reads an ASN.1 Biostruc text file into memory
    // and visits its components

    #include <serial/serial.hpp>
    #include <serial/iterator.hpp>
    #include <serial/objistr.hpp>
    #include <serial/serial.hpp>
    #include <objects/general/Dbtag.hpp>
    #include <objects/general/Object_id.hpp>
    #include <objects/seq/Numbering.hpp>
    #include <objects/seq/Pubdesc.hpp>
    #include <objects/seq/Heterogen.hpp>
    #include <objects/mmdb1/Biostruc.hpp>
    #include <objects/mmdb1/Biostruc_id.hpp>
    #include <objects/mmdb1/Biostruc_history.hpp>
    #include <objects/mmdb1/Mmdb_id.hpp>
    #include <objects/mmdb1/Biostruc_descr.hpp>
    #include <objects/mmdb1/Biomol_descr.hpp>
    #include <objects/mmdb1/Molecule_graph.hpp>
    #include <objects/mmdb1/Inter_residue_bond.hpp>
    #include <objects/mmdb1/Residue_graph.hpp>
    #include <objects/mmdb3/Biostruc_feature_set.hpp>
    #include <objects/mmdb2/Biostruc_model.hpp>
    #include <objects/pub/Pub.hpp>
    #include <corelib/ncbistre.hpp>

    #include "traverseBS.hpp"

    USING_NCBI_SCOPE;
    using namespace objects;

    int CTestAsn::Run()
    {
        // initialize ASN input stream
        auto_ptr<CObjectIStream>
            inObject(CObjectIStream::Open("1001.val", eSerial_AsnBinary));
        // initialize, read into, and traverse CBiostruc object
        CBiostruc bs;
        *inObject >> bs;
        Visit (bs);
        return 0;
    }

    /*****************************************************************
    *
    * The overloaded free "visit" functions are used to explore the
    * Biostruc and all its component members - most of which are also
    * class objects. Each class has a public interface that provides
    * access to its private data via "get" functions.
    *
    ******************************************************************/
    void Visit (const CBiostruc& bs)
    {
        cout << "Biostruc:\n" << endl;
        Visit (bs.GetId());
        Visit (bs.GetDescr());
        Visit (bs.GetChemical_graph());
        Visit (bs.GetFeatures());
        Visit (bs.GetModel());
    }

    /************************************************************************
    *
    * TId is a type defined in the CBiostruc class as a list of CBiostruc_id,
    * where each id has a choice state and a value. Depending on the choice
    * state, a different get() function is used.
    *
    *************************************************************************/
    void Visit (const CBiostruc::TId& idList)
    {
        cout << "\n Visiting Ids of Biostruc:\n";

        for (CBiostruc::TId::const_iterator i = idList.begin();
            i != idList.end(); ++i) {

            // dereference the iterator to get to the id object
            const CBiostruc_id& thisId = **i;
            CBiostruc_id::E_Choice choice = thisId.Which();
            cout << "choice = " << choice;

            // select id's get member function depending on choice
            switch (choice) {
            case CBiostruc_id::e_Mmdb_id:
                cout << " mmdbId: " << thisId.GetMmdb_id().Get() << endl;
                break;
            case CBiostruc_id::e_Local_id:
                cout << " Local Id: " << thisId.GetLocal_id().GetId() << endl;
               break;
            case CBiostruc_id::e_Other_database:
                cout << " Other DB Id: "
                << thisId.GetOther_database().GetDb() << endl;
                break;
            default:
                cout << "Choice not set or unrecognized" << endl;
            }
        }
    }

    /*************************************************************************
    *
    * TDescr is also a type defined in the Biostruc class as a list of
    * CBiostruc_descr, where each descriptor has a choice state and a value.
    *
    *************************************************************************/
    void Visit (const CBiostruc::TDescr& descList)
    {
        cout << "\n Visiting Descriptors of Biostruc:\n";

        for (CBiostruc::TDescr::const_iterator i = descList.begin();
            i != descList.end(); ++i) {

            // dereference the iterator to get the descriptor
            const CBiostruc_descr& thisDescr = **i;
            CBiostruc_descr::E_Choice choice = thisDescr.Which();
            cout << "choice = " << choice;

            // select the get function depending on choice
            switch (choice) {
            case CBiostruc_descr::e_Name:
                cout << " Name: " << thisDescr.GetName() << endl;
                break;
            case CBiostruc_descr::e_Pdb_comment:
                cout << " Pdb comment: " << thisDescr.GetPdb_comment() << endl;
                break;
            case CBiostruc_descr::e_Other_comment:
                cout << " Other comment: " << thisDescr.GetOther_comment() << endl;
                break;
            case CBiostruc_descr::e_History:
                cout << " History: " << endl;
                Visit (thisDescr.GetHistory());
                break;
            case CBiostruc_descr::e_Attribution:
                cout << " Attribute: " << endl;
                Visit (thisDescr.GetAttribution());
                break;
            default:
                cout << "Choice not set or unrecognized" << endl;
            }
        }
        VisitWithIterator (descList);
    }

    /****************************************************************************
    *
    * An alternate way to visit the descriptor nodes using a CStdTypeIterator
    *
    ****************************************************************************/
    void VisitWithIterator (const CBiostruc::TDescr& descList)
    {
        cout << "\n Revisiting descriptor list with string iterator...:\n";

        for (CBiostruc::TDescr::const_iterator i1 = descList.begin();
            i1 != descList.end(); ++i1) {

            const CBiostruc_descr& thisDescr = **i1;

            for (CStdTypeConstIterator<NCBI_NS_STD::string>
                i = ConstBegin(thisDescr); i; ++i) {
                cout << "next descriptor" << *i << endl;
            }
        }
    }

    /****************************************************************************
    *
    * Chemical graphs contain lists of descriptors, molecule_graphs, bonds, and
    * residue graphs. Here we just visit some of the descriptors.
    *
    ****************************************************************************/
    void Visit (const CBiostruc::TChemical_graph& G)
    {
        cout << "\n\n Visiting Chemical Graph of Biostruc\n";

        const CBiostruc_graph::TDescr& descList = G.GetDescr();
        for (CBiostruc_graph::TDescr::const_iterator i = descList.begin();
            i != descList.end(); ++i) {

            // dereference the iterator to get the descriptor
            const CBiomol_descr& thisDescr = **i;
            CBiomol_descr::E_Choice choice = thisDescr.Which();
            cout << "choice = " << choice;


            // select the get function depending on choice
            switch (choice) {
            case CBiomol_descr::e_Name:
                cout << " Name: " << thisDescr.GetName() << endl;
                break;
            case CBiomol_descr::e_Pdb_class:
                cout << " Pdb class: " << thisDescr.GetPdb_class() << endl;
                break;
            case CBiomol_descr::e_Pdb_source:
                cout << " Pdb Source: " << thisDescr.GetPdb_source() << endl;
                break;
            case CBiomol_descr::e_Pdb_comment:
                cout << " Pdb comment: " << thisDescr.GetPdb_comment() << endl;
                break;
            case CBiomol_descr::e_Other_comment:
                cout << " Other comment: " << thisDescr.GetOther_comment() << endl;
                break;
            case CBiomol_descr::e_Organism: // skipped
            case CBiomol_descr::e_Attribution:
                break;
            case CBiomol_descr::e_Assembly_type:
                cout << " Assembly Type: " << thisDescr.GetAssembly_type() << endl;
                break;
            case CBiomol_descr::e_Molecule_type:
                cout << " Molecule Type: " << thisDescr.GetMolecule_type() << endl;
                break;
            default:
                cout << "Choice not set or unrecognized" << endl;
            }
        }
    }

    void Visit (const CBiostruc::TFeatures&)
    {
        cout << "\n\n Visiting Features of Biostruc\n";
    }

    void Visit (const CBiostruc::TModel&)
    {
        cout << "\n\n Visiting Models of Biostruc\n";
    }

    int main(int argc, const char* argv[])
    {
        // initialize diagnostic stream
        CNcbiOfstream diag("traverseBS.log");
        SetDiagStream(&diag);

        CTestAsn theTestApp;
        return theTestApp.AppMain(argc, argv);
    }

<span class="nctnt ncbi-code">Visit(bs)</span> simply calls <span class="nctnt ncbi-func">Visit()</span> on each of the <span class="nctnt ncbi-class">CBiostruc</span> data members, which are accessed using <span class="nctnt ncbi-code">bs.GetXxx()</span>. The information needed to write each of these functions - the data member types and member function signatures - is contained in the respective header files. For example, looking at [Biostruc\_.hpp](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb1/Biostruc_.hpp), we learn that the structure's descriptor list can be accessed using <span class="nctnt ncbi-func">GetDescr()</span>, and that the type returned is a list of pointers to descriptors:

    typedef list< CRef<CBiostruc_descr> > TDescr;
    const TDescr& GetDescr(void) const;

Consulting the base class for [CBiostruc\_desc](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CBiostruc_descr_Base) in turn, we learn that this class has a <span class="nctnt ncbi-monospace">choice state</span> defining the type of value stored there as well as the method that should be used to access that value. This leads to an implementation of [Visit(CBiostruc::TDescr DescrList)](#visitcbiostructdescr-descrlist) that uses an iterator over its list argument and a switch statement over the current descriptor's choice state.

### Iterating Over Containers

Most of the <span class="nctnt ncbi-func">Visit()</span> functions implemented here rely on standard STL iterators to walk through a list of objects. The general syntax for using an iterator is:

    ContainerType ContainerName;
    ITERATE(ContainerType, it, ContainerName) {
        ObjectType ObjectName = *it;
        // ...
    }

Dereferencing the iterator is required, as the iterator behaves like a pointer that traverses consecutive elements of the container. For example, to iterate over the list of descriptors in the *Biostruc*, we use a container of type <span class="nctnt ncbi-type">CBiostruc::TDescr</span>, and the constant version of the <span class="nctnt ncbi-macro">ITERATE</span> macro to ensure that the data is not mutated in the body of the loop. Because the descriptor list contains pointers ([CRefs](ch_core.html#ch_core.CRef)) to objects, we will actually need to dereference **twice** to get to the objects themselves.

    ITERATE(CBiostruc::TDescr, it, descList) {
        const CBiostruc_descr& thisDescr = **it;
        // ...
    }

In traversing the descriptor list in this example, we handled each type of descriptor with an explicit <span class="nctnt ncbi-code">case</span> statement. In fact, however, we really only visit those descriptors whose types have string representations: <span class="nctnt ncbi-type">TName, TPdb\_comment</span>, and <span class="nctnt ncbi-type">TOther\_comment</span>. The other two descriptor types, <span class="nctnt ncbi-type">THistory</span> and <span class="nctnt ncbi-type">TAttribute</span>, are objects that are "visited" recursively, but the associated visit functions are not actually implemented (see [Code Sample 5](#code-sample-5), <span class="nctnt ncbi-path">traverseBS.hpp</span>).

#### Code Sample 5. traverseBS.hpp

    // File name traverseBS.hpp

    #ifndef NCBI_TRAVERSEBS__HPP
    #define NCBI_TRAVERSEBS__HPP

    #include <corelib/ncbistd.hpp>
    #include <corelib/ncbiapp.hpp>

    USING_NCBI_SCOPE;
    using namespace objects;

    // class CTestAsn
    class CTestAsn : public CNcbiApplication {
    public:
        virtual int Run ();
    };

    void Visit(const CBiostruc&);
    void Visit(const CBiostruc::TId&);
    void Visit(const CBiostruc::TDescr&);
    void Visit(const CBiostruc::TChemical_graph&);
    void Visit(const CBiostruc::TFeatures&);
    void Visit(const CBiostruc::TModel&);
    void Visit(const CBiostruc_history&) {
        cout << "visiting history" << endl;
    };

    // Not implemented
    void Visit(const CBiostruc_descr::TAttribution&) {};
    void VisitWithIterator (const CBiostruc::TDescr& descList);

    #endif /* NCBI_TRAVERSEBS__HPP */

The NCBI C++ Toolkit provides a rich and powerful [set of iterators](#set-of-iterators) for various application needs. An alternative to using the above <span class="nctnt ncbi-code">switch</span> statement to visit elements of the descriptor list would have been to use an NCBI [CStdTypeIterator](#cstdtypeiterator) that only visits strings. For example, we could implement the Visit function on a <span class="nctnt ncbi-type">CBiostruc::TDescr</span> as follows:

    void Visit(const CBiostruc::TDescr& descList)
    {
        ITERATE(CBiostruc::TDescr, it1, descList) {
            for (CStdTypeConstIterator<string> it2(ConstBegin(**it1));  it2;  ++it2) {
                cout << *it2 << endl;
            }
        }
    }

In this example, the iterator will skip over all but the string data members.

The <span class="nctnt ncbi-class">CStdTypeIterator</span> is one of several iterators which makes use of an object's <span class="nctnt ncbi-monospace">type information</span> to implement the desired functionality. We began this section by positing that the traversal of an object requires an a priori knowledge of that object's internal structure. This is not strictly true however, if type information for the object is also available. An object's type information specifies the class layout, inheritance relations, data member names, and various other attributes such as size, which are independent of specific instances. All of the C++ type iterators described in [The NCBI C++ Toolkit Iterators](#the-ncbi-c++-toolkit-iterators) section utilize type information, which is the topic of a previous section: [Runtime Object Type Information](#runtime-object-type-information).

Managing ASN.1 Specification Versions
-------------------------------------

Occasionally it is necessary to change an ASN.1 specification. However, if not designed properly, a new version of an ASN.1 specification can create incompatibilities between old data files and new software or old software and new data.

-   [The cardinal rule for adding new members](#the-cardinal-rule-for-adding-new-members)

-   [Background for the rule on adding new members](#background-for-the-rule-on-adding-new-members)

-   [Self-versioning types](#self-versioning-types)

-   [Skipping unknown data](#skipping-unknown-data)

### The cardinal rule for adding new members

The only rule you need to follow to achieve backward compatibility is:

> Only add new members to the end of a type, and always make them optional.

<span class="nctnt highlight">Note:</span> In this context, "backward compatibility" means the ability for new readers to read either old or new data.

### Background for the rule on adding new members

ASN.1 data writers are generally coded to follow a specific version of the specification, so version-related issues are quite improbable when writing. Data readers are also generally coded according to a given specification version, but the data they read could have been written by any writer version. Thus, problems due to version incompatibilities are most likely to occur when reading.

Text-format ASN.1 data files include member names with the data, so it's easy for the reader to ensure that the read data matches the specification.

Binary data files do not include member names. Instead, they include integer tags which are assumed to correspond to the ASN.1 specification. Therefore, if a new version of a specification inserts a new member between existing members, the tagging will be incompatible with the old version, and data corruption or a crash will result from attempting to read an old data file with a new reader or vice versa.

For example, suppose a specification is changed a la:

| Old Specification                                                                                                                                                                                                                                                                                                                     | New Specification                                                                                                                                                                                                                                                                                                                                                                                                                                |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span class="nctnt ncbi-monospace">Date ::= SEQUENCE {</span><br/><span class="nctnt ncbi-monospace"> year INTEGER ,</span><br/><span class="nctnt ncbi-monospace"> month INTEGER ,</span><br/><span class="nctnt ncbi-monospace"> day INTEGER }</span> | <span class="nctnt ncbi-monospace">Date ::= SEQUENCE {</span><br/><span class="nctnt ncbi-monospace"> year INTEGER ,</span><br/><span class="nctnt ncbi-monospace">**epoch VisibleString OPTIONAL ,**</span><br/><span class="nctnt ncbi-monospace"> month INTEGER ,</span><br/><span class="nctnt ncbi-monospace"> day INTEGER }</span> |

The old specification associates tag 2 with month and tag 3 with day; the new specification associates tag 2 with epoch, tag 3 with month, and tag 4 with day. Thus, if an old reader reads a new file it will choke on tag 4 and if a new reader reads an old file it will choke on the absence of tag 4.

However, suppose the specification is changed this way:

| Old Specification                                                                                                                                                                                                                                                                                                                     | New Specification                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span class="nctnt ncbi-monospace">Date ::= SEQUENCE {</span><br/><span class="nctnt ncbi-monospace"> year INTEGER ,</span><br/><span class="nctnt ncbi-monospace"> month INTEGER ,</span><br/><span class="nctnt ncbi-monospace"> day INTEGER }</span> | <span class="nctnt ncbi-monospace">Date ::= SEQUENCE {</span><br/><span class="nctnt ncbi-monospace"> year INTEGER **,**</span><br/><span class="nctnt ncbi-monospace"> month INTEGER ,</span><br/><span class="nctnt ncbi-monospace"> day INTEGER ,</span><br/><span class="nctnt ncbi-monospace">**epoch VisibleString OPTIONAL**</span><br/><span class="nctnt ncbi-monospace"> }</span> |

Now the new reader can read old data without any trouble. Old readers will not be able to read new data because tag 4 was not part of the specification they were built for so they will crash upon the first instance of epoch data (but they will read all data up to that point just fine).

Because of this, it's strongly recommended to add new field(s) as early as possible, preferably long before the new field(s) actually start getting written. This will allow a time for the old readers to get upgraded.

Therefore, the only backward-compatible way of adding new sequence members is to add them at the end, and to make them optional.

### Self-versioning types

It is conceivable that a "schema version" could be incorporated into a type beginning with the first version of the type. For example:

|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span class="nctnt ncbi-monospace">subsnp ::= SEQUENCE {</span><br/><span class="nctnt ncbi-monospace"> version INTEGER {</span><br/><span class="nctnt ncbi-monospace"> snp\_v1(1),</span><br/><span class="nctnt ncbi-monospace"> snp\_v2(2),</span><br/><span class="nctnt ncbi-monospace"> max\_version(255)</span><br/><span class="nctnt ncbi-monospace"> },</span><br/><span class="nctnt ncbi-monospace"> data CHOICE {</span><br/><span class="nctnt ncbi-monospace"> subsnp\_v1 SubSNP\_v1</span><br/><span class="nctnt ncbi-monospace"> subsnp\_v2 SubSNP\_v2</span><br/><span class="nctnt ncbi-monospace">}</span> |

However, old readers would still not be able to read new data, so it's unclear what the advantage of this approach would have over simply adding optional members to the end of the type.

What is clear is that this approach could become very cumbersome to maintain if more than a few versions were created.

### Skipping unknown data

At some point, an old reader may encounter new data, in which case there will be unknown class members and/or choice variants. By default, this condition will cause an exception, but it is possible to skip unknown data using these functions:

-   [CObjectIStream::SetSkipUnknownMembers()](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStream.html#a752e6d807cc99bd80279d9833af3ae71)

-   [CObjectIStream::SetSkipUnknownVariants()](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/doxyhtml/classCObjectIStream.html#ac36b639e833b47220261fa559e26eee9)

There are two different methods because one is relatively safe and the other is not.

If you call <span class="nctnt ncbi-func">SetSkipUnknownMembers()</span> then unknown members will be essentially ignored and the application can process new data in the same way it would process old data.

If you call <span class="nctnt ncbi-func">SetSkipUnknownVariants()</span> then a lack of coding rigor may cause a problem. Specifically, a choice object won't be set if new data contains an unknown (and therefore skipped) variant. If your code expects the choice object to be set and doesn't verify that it is, then it could cause data corruption and/or crashing.

SOAP support
------------

The NCBI C++ Toolkit SOAP server and client provide a limited level of support of SOAP 1.1 over HTTP, and use the document binding style with a literal schema definition. Document/literal is the style that most Web services platforms were focusing on when this feature was introduced. Parsing of WSDL (Web services description language) specification and automatic C++ code generation are not supported. Still, since the WSDL message types section uses XML schema, and since the application is capable of parsing Schema, the majority of the C++ code generation can be done automatically.

### SOAP message

The core section of the SOAP specification is the messaging framework. The client sends a request and receives a response in the form of a SOAP message. A SOAP message is a one-way transmission between SOAP nodes: from a SOAP sender to a SOAP receiver. The root element of a SOAP message is the <span class="nctnt ncbi-monospace">Envelope</span>. The <span class="nctnt ncbi-monospace">Envelope</span> contains an optional <span class="nctnt ncbi-monospace">Header</span> element followed by a mandatory <span class="nctnt ncbi-monospace">Body</span> element. The <span class="nctnt ncbi-monospace">Body</span> element represents the message payload - it is a generic container that can contain any number of elements from any namespace.

In the Toolkit, the [CSoapMessage](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=CSoapMessage) class defines <span class="nctnt ncbi-monospace">Header</span> and <span class="nctnt ncbi-monospace">Body</span> containers. Serializable objects (derived from the [CSerialObject](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSerialObject) class) can be added into these containers using <span class="nctnt ncbi-func">AddObject()</span> method. Such a message object can then be sent to a message receiver. The response will also come in the form of an object derived from [CSoapMessage](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=CSoapMessage). At this time, it is possible to investigate its contents using <span class="nctnt ncbi-func">GetContent()</span> method; or ask directly for an object of a specific type using the [SOAP\_GetKnownObject()](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=SOAP_GetKnownObject) template function.

### SOAP client ([CSoapHttpClient](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSoapHttpClient))

The SOAP client is the initial SOAP sender - a node that originates a SOAP message. Knowing the SOAP receiver's URL, it sends a SOAP request and receives a response using the <span class="nctnt ncbi-func">Invoke()</span> method.

Internally, data objects in the Toolkit SOAP library are serialized and de-serialized using serializable objects streams. Since each serial data object also provides access to its type information, writing such objects is a straightforward operation. Reading the response is not that transparent. Before actually parsing incoming data, the SOAP processor should decide which object type information to use. Hence, a client application should tell the SOAP processor what types of data objects it might encounter in the incoming data. If the processor recognizes the object's type, it will parse the incoming data and store it as an instance of the recognized type. Otherwise, the processor will parse the data into an instance of the [CAnyContentObject](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CAnyContentObject) class.

So, a SOAP client must:

-   Define the server's URL.

-   Register the object types that might be present in the incoming data (using the <span class="nctnt ncbi-func">RegisterObjectType()</span> method).

The [CSoapHttpClient](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSoapHttpClient) class also has methods for getting and setting the server URL and the default namespace.

### SOAP server ([CSoapServerApplication](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/ident?i=CSoapServerApplication))

The SOAP server receives SOAP mesages from a client and processes the contents of the SOAP Body and SOAP Header.

The processing of incoming requests is done with the help of "message listeners" - the server methods which analyze requests (in the form of objects derived from [CSoapMessage](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=CSoapMessage)) and create responses. It is possible to have more than one listener for each message. When such a listener returns TRUE, the SOAP server base class object passes the request to the next listener, if it exists, and so on.

The server can return a WSDL specification if the specification file name is passed to the server's constructor and the file is located with the server.

### Generating a SOAP client using DATATOOL

DATATOOL can be used to conveniently create SOAP client source code, for example:

    datatool -m soap_server_sample.wsdl -oA -oc sample -oph sample  -opc sample -orq

The following topics in the [DATATOOL documentation](ch_app.html#ch_app.datatool) contain additional details:

-   [Code generation arguments](ch_app.html#ch_app.datatool.html_refCodeGenerationAr)

-   [Generated code](ch_app.html#ch_app.datatool.html_refCode)

### Sample SOAP server and client

The Toolkit contains a simple example of SOAP client and server in its <span class="nctnt ncbi-path">src/sample/app/soap</span> folder.

The sample SOAP server supports the following operations:

<span class="nctnt ncbi-func">GetDescription()</span> - server receives an empty object of type Description, and it sends back a single string;

<span class="nctnt ncbi-func">GetVersion()</span> - server receives a string, and it sends back two integer numbers and a string;

<span class="nctnt ncbi-func">DoMath()</span> - server receives a list of Operand objects (two integers and an enumerated value), and it sends back a list of integers

The starting point is the WSDL specification - <span class="nctnt ncbi-path">src\\sample\\app\\soap\\server\\soap\_server\_sample.wsdl</span>

Both client and server use data objects whose types are described in the message types section of WSDL specification. So, we extract the XML schema part of the specification into a separate file, and create a static library - <span class="nctnt ncbi-lib">soap\_dataobj</span>. All code in this library is generated automatically by .

#### Sample server

Server is a CGI application. In its constructor we define the name of WSDL specification file and the default namespace for the data objects. Since server's ability to return a WSDL specification upon request from a client is optional, it is possible to give an empty file name here. Once the name is not empty, the WSDL file should be deployed alongside the server.

During initialization server should register incoming object types and message listeners:

<span class="nctnt ncbi-code">// Register incoming object types, so the SOAP message parser can</span>

<span class="nctnt ncbi-code">// recognize these objects in incoming data and parse them correctly.</span>

<span class="nctnt ncbi-code">RegisterObjectType(CVersion::GetTypeInfo);</span>

<span class="nctnt ncbi-code">RegisterObjectType(CMath::GetTypeInfo);</span>

<span class="nctnt ncbi-code">// Register SOAP message processors.</span>

<span class="nctnt ncbi-code">// It is possible to set more than one listeners for a particular message;</span>

<span class="nctnt ncbi-code">// such listeners will be called in the order of registration.</span>

<span class="nctnt ncbi-code">AddMessageListener((TWebMethod)(&CSampleSoapServerApplication::GetDescription), "Description"); AddMessageListener((TWebMethod)(&CSampleSoapServerApplication::GetDescription2), "Description");</span>

<span class="nctnt ncbi-code">AddMessageListener((TWebMethod)(&CSampleSoapServerApplication::GetVersion), "Version");</span>

<span class="nctnt ncbi-code">AddMessageListener((TWebMethod)(&CSampleSoapServerApplication::DoMath), "Math");</span>

Note that while it is possible to register the <span class="nctnt ncbi-monospace">Description</span> type, it does not make much sense: the object has no content, so there is no difference whether it will be parsed correctly or not.

Message listeners are user-defined functions that process incoming messages. They analyze the content of SOAP message request and populate the response object.

#### Sample client

Unlike SOAP server, SOAP client object has nothing to do with [CCgiApplication](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/search?string=CCgiApplication) class. It is "just" an object. As such, it can be created and destroyed when appropriate. Sample SOAP client constructor defines the server URL and the default namespace for the data objects. Its constructor is the proper place to register incoming object types:

<span class="nctnt ncbi-code">// Register incoming object types, so the SOAP message parser can</span>

<span class="nctnt ncbi-code">// recognize these objects in incoming data and parse them correctly.</span>

<span class="nctnt ncbi-code">RegisterObjectType(CDescriptionText::GetTypeInfo);</span>

<span class="nctnt ncbi-code">RegisterObjectType(CVersionResponse::GetTypeInfo);</span>

<span class="nctnt ncbi-code">RegisterObjectType(CMathResponse::GetTypeInfo);</span>

Other methods encapsulate operations supported by the SOAP server, which the client talks to. Common schema is to create two SOAP message object - request and response, populate request object, call <span class="nctnt ncbi-func">Invoke()</span> method of the base class, and extract the meaningful data from the response.

Test Cases [[src/serial/test](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/serial/test)]
----------------------------------------------------------------------------------------------------------

[Available Serializable Classes](ch_proj.html#ch_proj.ser_object) (as per NCBI ASN.1 Specifications) [Library <span class="nctnt ncbi-path">xobjects</span>: [include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects)]

The ASN.1 data objects are automatically built from their corresponding specifications in the NCBI ASN.1 data model, using [DATATOOL](ch_app.html#ch_app.datatool) to generate all of the required source code. This set of serializable classes defines an interface to many important sequence and sequence-aware objects that users may directly employ, or extend with their own code. An <span class="nctnt ncbi-monospace">Object Manager</span>[(see below)](ch_objmgr.html) coordinates and simplifies the use of these ASN.1-derived objects.

Serializable Classes

-   access [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/access) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/access)]

-   biblio [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/biblio) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/biblio)]

-   cdd [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/cdd) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/cdd)]

-   cn3d [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/cn3d) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/cn3d)]

-   docsum [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/docsum) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/docsum)]

-   entrez2 [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/entrez2) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/entrez2)]

-   featdef [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/featdef) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/featdef)]

-   general [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/general) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/general)]

-   id1 [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/id1) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/id1)]

-   medlars [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/medlars) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/medlars)]

-   medline [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/medline) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/medline)]

-   mim [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mim) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mim)]

-   mla [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mla) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mla)]

-   mmdb1 [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb1) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mmdb1)]

-   mmdb2 [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb2) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mmdb2)]

-   mmdb3 [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/mmdb3) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/mmdb3)]

-   ncbimime [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/ncbimime) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/ncbimime)]

-   objprt [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/objprt) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/objprt)]

-   proj [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/proj) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/proj)]

-   pub [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/pub) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/pub)]

-   pubmed [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/pubmed) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/pubmed)]

-   seq [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seq) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seq)]

-   seqalign [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqalign) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqalign)]

-   seqblock [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqblock) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqblock)]

-   seqcode [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqcode) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqcode)]

-   seqfeat [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqfeat) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqfeat)]

-   seqloc [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqloc) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqloc)]

-   seqres [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqres) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqres)]

-   seqset [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/seqset) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/seqset)]

-   submit [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/submit) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/submit)]

-   taxon1 [[include](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/include/objects/taxon1) \\| [src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/objects/taxon1)]

A Test Application Using the Serializable ASN.1 Classes

-   asn2asn [[src](http://www.ncbi.nlm.nih.gov/IEB/ToolBox/CPP_DOC/lxr/source/src/app/asn2asn/)]


